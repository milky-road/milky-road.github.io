<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Coordinator 패턴을 사용한 네비게이션 방법 | milky-road</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://milky-road.github.io///post/2024-07-01-NavigationviaCoordinatorPattern" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Coordinator 패턴을 사용한 네비게이션 방법 | milky-road" data-gatsby-head="true"/><meta property="og:title" content="Coordinator 패턴을 사용한 네비게이션 방법 | milky-road" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://milky-road.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://milky-road.github.io///post/2024-07-01-NavigationviaCoordinatorPattern" data-gatsby-head="true"/><meta name="twitter:title" content="Coordinator 패턴을 사용한 네비게이션 방법 | milky-road" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | milky-road" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-01 20:53" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-0NB9FGTFEQ"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-0NB9FGTFEQ');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-73566c14eda4dde6.js" defer=""></script><script src="/_next/static/7hNDOmve0zHk5f26XIl6c/_buildManifest.js" defer=""></script><script src="/_next/static/7hNDOmve0zHk5f26XIl6c/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Milky Road</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Coordinator 패턴을 사용한 네비게이션 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Coordinator 패턴을 사용한 네비게이션 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Milky Road</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 1, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-01-NavigationviaCoordinatorPattern&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>각 화면을 포함하는 앱은 사용자가 인터페이스를 탐색하고 다른 기능에 액세스할 수 있는 시스템이 필요합니다. 내장된 네비게이션 컨트롤러와 같은 도구를 통해 또는 사용자 정의 솔루션을 통해 이러한 네비게이션을 구현하는 것은 복잡할 수 있습니다. 잘 설계된 네비게이션 구조는 앱의 다른 부분이 독립적이고 유지보수가 쉽도록 보장하여 뷰 컨트롤러 간에 강하게 결합되지 않고 널리 퍼져 있는 종속성을 피합니다.</p>
<p><img src="/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png" alt="Navigation Structure"></p>
<h1>문제점은 무엇인가요?</h1>
<p>iOS 앱에서 네비게이션을 관리하는 일반적인 방법은 UINavigationController를 사용하는 것입니다. 이 컨트롤러는 뷰 컨트롤러를 푸시하고 팝하여 화면 간의 전환을 원활하고 쉽게 처리합니다. 예를 들어:</p>
<div class="content-ad"></div>
<p>이 접근 방식을 통해 한 뷰 컨트롤러가 다른 뷰 컨트롤러를 알고 만들고 구성하며 표시하는 역할을 맡게 됩니다. 이는 애플리케이션에서 뷰 컨트롤러 사이의 링크가 하드 코딩되므로 응집력이 높습니다. 결과적으로, 동일한 뷰 컨트롤러를 다른 위치에서 표시해야 한다면 구성 코드를 중복해서 작성해야 할 수도 있습니다.</p>
<p>Coordinator 패턴에서는 ViewController가 새로운 ViewController를 만들고 구성하는 역할을 맡은 Coordinator와만 통신합니다. 이 접근 방식은 ViewController들이 서로 분리되어 있으며 이동할 특정 ViewController를 알지 못하도록 보장하기 때문에 더 정리되고 유지보수가 편리한 코드베이스를 유지할 수 있습니다.</p>
<h1>Coordinator 만들기를 시작해봅시다.</h1>
<div class="content-ad"></div>
<p>두 개의 프로토콜을 생성해야 합니다. 첫 번째 프로토콜은 모든 코디네이터가 따를 기본 구조를 포함할 것입니다. 두 번째 프로토콜은 메인 코디네이터에 특화됩니다. 이 두 번째 프로토콜은 코디네이터와 뷰 컨트롤러 간의 커뮤니케이션을 원활히 할 것입니다.</p>
<p>Markdown 형식으로 위 코드를 조금 수정해주시면 좋을 것 같네요.</p>
<p>처음에는 모든 코디네이터가 준수해야 할 Coordinator 프로토콜을 생성해야 합니다. 기본적인 구조를 따르는 것이 좋습니다:</p>
<ul>
<li>Child Coordinators 속성: 자식 코디네이터를 저장하는 속성을 추가합니다.</li>
<li>Navigation Controller 속성: 뷰 컨트롤러를 표시하는 데 사용될 네비게이션 컨트롤러를 보유하는 속성을 포함합니다.</li>
<li>Start 메서드: 코디네이터가 제어를 가져갈 수 있도록 start() 메서드를 정의합니다. 이렇게 하면 필요할 때만 코디네이터를 생성하고 활성화할 수 있습니다.</li>
</ul>
<div class="content-ad"></div>
<p>이제 ViewController를 만들 수 있는 확장 프로그램을 추가해서 조금 더 쉽게 작업할 수 있게 되었어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">UIKit</span>

public enum <span class="hljs-title class_">Storyboard</span>: <span class="hljs-title class_">String</span> {
    <span class="hljs-keyword">case</span> main = <span class="hljs-string">"Main"</span>

    <span class="hljs-keyword">var</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">UIStoryboard</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">UIStoryboard</span>(<span class="hljs-attr">name</span>: self.<span class="hljs-property">rawValue</span>, <span class="hljs-attr">bundle</span>: <span class="hljs-title class_">Bundle</span>.<span class="hljs-property">main</span>)
    }

    func viewController&#x3C;<span class="hljs-attr">T</span>: <span class="hljs-title class_">UIViewController</span>>(<span class="hljs-attr">viewControllerClass</span>: T.<span class="hljs-property">Type</span>, <span class="hljs-attr">function</span>: <span class="hljs-title class_">String</span> = #<span class="hljs-keyword">function</span>, <span class="hljs-attr">line</span>: <span class="hljs-title class_">Int</span> = #line, <span class="hljs-attr">file</span>: <span class="hljs-title class_">String</span> = #file) -> T {
        <span class="hljs-keyword">let</span> storyboardID = (viewControllerClass <span class="hljs-keyword">as</span> <span class="hljs-title class_">UIViewController</span>.<span class="hljs-property">Type</span>).<span class="hljs-property">storyboardID</span>
        guard <span class="hljs-keyword">let</span> scene = instance.<span class="hljs-title function_">instantiateViewController</span>(<span class="hljs-attr">withIdentifier</span>: storyboardID) <span class="hljs-keyword">as</span>? T <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">fatalError</span>(<span class="hljs-string">"ViewController with identifier \(storyboardID), not found in \(self.rawValue) Storyboard.\nFile : \(file) \nLine Number : \(line) \nFunction : \(function)"</span>)
        }

        <span class="hljs-keyword">return</span> scene
    }

    <span class="hljs-keyword">static</span> func initialViewController&#x3C;<span class="hljs-attr">T</span>: <span class="hljs-title class_">UIViewController</span>>(<span class="hljs-attr">viewControllerClass</span>: T.<span class="hljs-property">Type</span>, <span class="hljs-attr">function</span>: <span class="hljs-title class_">String</span> = #<span class="hljs-keyword">function</span>, <span class="hljs-attr">line</span>: <span class="hljs-title class_">Int</span> = #line, <span class="hljs-attr">file</span>: <span class="hljs-title class_">String</span> = #file) -> T {
         <span class="hljs-keyword">let</span> storyboardID = (viewControllerClass <span class="hljs-keyword">as</span> <span class="hljs-title class_">UIViewController</span>.<span class="hljs-property">Type</span>).<span class="hljs-property">storyboardID</span>
         guard <span class="hljs-keyword">let</span> scene = <span class="hljs-title class_">UIStoryboard</span>(<span class="hljs-attr">name</span>: storyboardID, <span class="hljs-attr">bundle</span>: <span class="hljs-title class_">Bundle</span>.<span class="hljs-property">main</span>).<span class="hljs-title function_">instantiateViewController</span>(<span class="hljs-attr">withIdentifier</span>: storyboardID) <span class="hljs-keyword">as</span>? T <span class="hljs-keyword">else</span> {
             <span class="hljs-title function_">fatalError</span>(<span class="hljs-string">"ViewController with identifier \(storyboardID), not found in \(storyboardID) Storyboard.\nFile : \(file) \nLine Number : \(line) \nFunction : \(function)"</span>)
         }
         <span class="hljs-keyword">return</span> scene
     }
}

extension <span class="hljs-title class_">UIViewController</span> {

    <span class="hljs-keyword">class</span> <span class="hljs-title class_">var</span> <span class="hljs-attr">storyboardID</span>: <span class="hljs-title class_">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"\(self)"</span>
    }

    <span class="hljs-keyword">static</span> func <span class="hljs-title function_">instantiate</span>() -> <span class="hljs-title class_">Self</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Storyboard</span>.<span class="hljs-title function_">initialViewController</span>(<span class="hljs-attr">viewControllerClass</span>: self)
    }
}
</code></pre>
<p>이제 ViewController를 쉽게 만들 수 있는 능력을 갖게 되었어요. 세팅할 때 더 이상 스토리보드에 의존하지 않아도 돼요. 하지만 스토리보드는 여전히 간단한 디자인을 표시하는 데 유용해요. 그래서 저는 프로젝트에서 그것들을 사용하는 것을 선호해요. 우리 자신의 스토리보드를 만들고 그것들을 코디네이터에 통합함으로써, 유연성과 간단함 사이의 균형을 이룰 수 있어요.</p>
<p>메인 스토리보드 참조를 제거했어요.</p>
<div class="content-ad"></div>
<h2>탐색 관리를 위한 MainCoordinator 작성하기</h2>
<p>코디네이터 기반의 탐색의 핵심에는 MainCoordinator 개념이 있습니다. 이 코디네이터는 앱의 탐색 계층 구조로의 진입점 역할을 합니다. 필요한 구성 요소를 초기화하고 앱의 초기 상태를 설정하며 사용자를 다양한 화면과 작업 흐름을 통해 안내합니다. 이를 생성해보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">UIKit</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainCoordinator</span>: <span class="hljs-title class_">Coordinator</span> {
    <span class="hljs-keyword">var</span> childCoordinators = [<span class="hljs-title class_">Coordinator</span>]()
    <span class="hljs-keyword">var</span> <span class="hljs-attr">navigationController</span>: <span class="hljs-title class_">UINavigationController</span>
    
    <span class="hljs-title function_">init</span>(<span class="hljs-params">navigationController: UINavigationController</span>) {
        self.<span class="hljs-property">navigationController</span> = navigationController
    }
    
    func <span class="hljs-title function_">start</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> vc = <span class="hljs-title class_">InitialViewController</span>.<span class="hljs-title function_">instantiate</span>()
        vc.<span class="hljs-property">coordinator</span> = self
        navigationController.<span class="hljs-title function_">pushViewController</span>(vc, <span class="hljs-attr">animated</span>: <span class="hljs-literal">false</span>)
    }
}
</code></pre>
<div class="content-ad"></div>
<h3>1. Properties:</h3>
<ul>
<li><code>childCoordinators</code>: An array to keep track of any child coordinators.</li>
<li><code>navigationController</code>: A navigation controller used for managing view controllers.</li>
</ul>
<h3>2. Initializer:</h3>
<ul>
<li>It initializes the <code>MainCoordinator</code> with a navigation controller.</li>
</ul>
<div class="content-ad"></div>
<ol start="3">
<li>시작 메서드:</li>
</ol>
<ul>
<li>이 방법은 조정 프로세스를 시작하는 데 사용됩니다.</li>
<li>InitialViewController를 인스턴스화하고 앱의 시작점을 설정합니다.</li>
<li>InitialViewController의 조정자를 자체로 설정합니다.</li>
<li>InitialViewController를 네비게이션 스택에 푸시합니다.</li>
</ul>
<p>SceneDelegate.swift에서 조정자 수동으로 초기화하기</p>
<p>애플리케이션을 위해 조정자를 설정한 후에는 앱이 실행될 때 활성화해야 합니다. 일반적으로 이 초기화는 스토리보드에서 처리하지만, 해당 기능을 비활성화했다면, 이제 SceneDelegate.swift 파일 내에서 직접 시작 프로세스를 관리해야 합니다.</p>
<div class="content-ad"></div>
<h3>메인 코디네이터 초기화:</h3>
<ol>
<li>UINavigationController의 인스턴스를 생성합니다.</li>
<li>이 내비게이션 컨트롤러로 MainCoordinator를 초기화합니다.</li>
</ol>
<h3>코디네이터 시작:</h3>
<ol>
<li>내비게이션 컨트롤러를 윈도우의 루트 뷰 컨트롤러로 할당합니다.</li>
<li>플로우를 시작하려면 코디네이터의 start() 메서드를 호출합니다.</li>
</ol>
<div class="content-ad"></div>
<p>여기 세련된 구현 방법이 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">UIKit</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SceneDelegate</span>: <span class="hljs-title class_">UIResponder</span>, <span class="hljs-title class_">UIWindowSceneDelegate</span> {
    
    <span class="hljs-keyword">var</span> <span class="hljs-attr">window</span>: <span class="hljs-title class_">UIWindow</span>?
    <span class="hljs-keyword">var</span> <span class="hljs-attr">mainCoordinator</span>: <span class="hljs-title class_">MainCoordinator</span>?
    
    func <span class="hljs-title function_">scene</span>(<span class="hljs-params">_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions</span>) {
        guard <span class="hljs-keyword">let</span> windowScene = (scene <span class="hljs-keyword">as</span>? <span class="hljs-title class_">UIWindowScene</span>) <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
        
        <span class="hljs-keyword">let</span> navController = <span class="hljs-title class_">UINavigationController</span>()
        mainCoordinator = <span class="hljs-title class_">MainCoordinator</span>(<span class="hljs-attr">navigationController</span>: navController)
        mainCoordinator?.<span class="hljs-title function_">start</span>()
        
        <span class="hljs-variable language_">window</span> = <span class="hljs-title class_">UIWindow</span>(<span class="hljs-attr">windowScene</span>: windowScene)
        <span class="hljs-variable language_">window</span>?.<span class="hljs-property">rootViewController</span> = navController
        <span class="hljs-variable language_">window</span>?.<span class="hljs-title function_">makeKeyAndVisible</span>()
    }
</code></pre>
<p>간단한 예제로 흐름을 이어보겠습니다;</p>
<p>이를 위해 애플리케이션의 시작점인 InitialViewController에서 이동할 다른 페이지가 필요합니다. 이 간단한 예제에서 RedViewController와 BlueViewController 두 개의 컨트롤러를 만들었습니다. InitialViewController의 두 버튼을 사용하여 이러한 페이지로 이동할 것입니다. 주의해야 할 점은, UIViewController에 대해 작성한 확장을 사용하려면 스토리보드 식별자를 올바르게 지정해야 합니다.</p>
<div class="content-ad"></div>
<p>첫째, 우리 각 뷰 컨트롤러는 그것의 코디네이터와 통신할 방법이 필요합니다. 따라서 ViewController 세 개 모두에 이 속성을 포함하세요.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> coordinator: <span class="hljs-type">MainCoordinator</span>?
</code></pre>
<p>메인 코디네이터에서 작성할 두 가지 메서드를 통해 페이지 간에 이동할 수 있을 것입니다.</p>
<div class="content-ad"></div>
<p>Navigator.py파일에 <code>navigateToBlue()</code> 및 <code>navigateToRed()</code> 메서드가 정의되어 있습니다.</p>
<p>이 메서드들은 InitialViewController에서 정의한 액션에서 호출됩니다.</p>
<p>InitialViewController에서는 다음과 같이 호출됩니다.</p>
<p>@IBAction func navigateToBlueVC(_ sender: Any) {
coordinator?.navigateToBlue()
}</p>
<pre><code>@IBAction func navigateToRedVC(_ sender: Any) {
    coordinator?.navigateToRed()
}
</code></pre>
<p>이제 코디네이터가 제어하는 각 뷰 컨트롤러 간에 탐색이 가능한 앱이 작동해야 합니다. 축하합니다!</p>
<div class="content-ad"></div>
<h1>결론</h1>
<p>Coordinator Pattern을 Swift에서 구현하면 iOS 애플리케이션 내에서 네비게이션을 처리하는 구조화되고 유지보수 가능한 방법을 제공합니다. 이 패턴을 사용하면 네비게이션 로직을 뷰 컨트롤러로부터 분리하여 더 깔끔한 코드베이스를 유지할 뿐만 아니라 재사용성을 향상시키고 테스트를 간단하게 만듭니다. 앱이 확장되면 Coordinator Pattern을 통해 네비게이션 아키텍처가 견고하고 적응성이 뛰어나게 유지되어 새로운 기능을 원활하게 통합할 수 있고 개발 프로세스를 더욱 원활하게 만들 수 있습니다. 이 패턴을 받아들이는 것은 더 모듈식이고 조직화된 Swift 애플리케이션으로 가는 한 걸음이며, 이는 최종적으로 더 나은 개발자 경험과 믿을 수 있는 앱을 제공하게 됩니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Coordinator 패턴을 사용한 네비게이션 방법","description":"","date":"2024-07-01 20:53","slug":"2024-07-01-NavigationviaCoordinatorPattern","content":"\n\n각 화면을 포함하는 앱은 사용자가 인터페이스를 탐색하고 다른 기능에 액세스할 수 있는 시스템이 필요합니다. 내장된 네비게이션 컨트롤러와 같은 도구를 통해 또는 사용자 정의 솔루션을 통해 이러한 네비게이션을 구현하는 것은 복잡할 수 있습니다. 잘 설계된 네비게이션 구조는 앱의 다른 부분이 독립적이고 유지보수가 쉽도록 보장하여 뷰 컨트롤러 간에 강하게 결합되지 않고 널리 퍼져 있는 종속성을 피합니다.\n\n![Navigation Structure](/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png)\n\n# 문제점은 무엇인가요?\n\niOS 앱에서 네비게이션을 관리하는 일반적인 방법은 UINavigationController를 사용하는 것입니다. 이 컨트롤러는 뷰 컨트롤러를 푸시하고 팝하여 화면 간의 전환을 원활하고 쉽게 처리합니다. 예를 들어:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 접근 방식을 통해 한 뷰 컨트롤러가 다른 뷰 컨트롤러를 알고 만들고 구성하며 표시하는 역할을 맡게 됩니다. 이는 애플리케이션에서 뷰 컨트롤러 사이의 링크가 하드 코딩되므로 응집력이 높습니다. 결과적으로, 동일한 뷰 컨트롤러를 다른 위치에서 표시해야 한다면 구성 코드를 중복해서 작성해야 할 수도 있습니다.\n\nCoordinator 패턴에서는 ViewController가 새로운 ViewController를 만들고 구성하는 역할을 맡은 Coordinator와만 통신합니다. 이 접근 방식은 ViewController들이 서로 분리되어 있으며 이동할 특정 ViewController를 알지 못하도록 보장하기 때문에 더 정리되고 유지보수가 편리한 코드베이스를 유지할 수 있습니다.\n\n# Coordinator 만들기를 시작해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 개의 프로토콜을 생성해야 합니다. 첫 번째 프로토콜은 모든 코디네이터가 따를 기본 구조를 포함할 것입니다. 두 번째 프로토콜은 메인 코디네이터에 특화됩니다. 이 두 번째 프로토콜은 코디네이터와 뷰 컨트롤러 간의 커뮤니케이션을 원활히 할 것입니다.\n\nMarkdown 형식으로 위 코드를 조금 수정해주시면 좋을 것 같네요.\n\n처음에는 모든 코디네이터가 준수해야 할 Coordinator 프로토콜을 생성해야 합니다. 기본적인 구조를 따르는 것이 좋습니다:\n\n- Child Coordinators 속성: 자식 코디네이터를 저장하는 속성을 추가합니다.\n- Navigation Controller 속성: 뷰 컨트롤러를 표시하는 데 사용될 네비게이션 컨트롤러를 보유하는 속성을 포함합니다.\n- Start 메서드: 코디네이터가 제어를 가져갈 수 있도록 start() 메서드를 정의합니다. 이렇게 하면 필요할 때만 코디네이터를 생성하고 활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 ViewController를 만들 수 있는 확장 프로그램을 추가해서 조금 더 쉽게 작업할 수 있게 되었어요.\n\n```js\nimport UIKit\n\npublic enum Storyboard: String {\n    case main = \"Main\"\n\n    var instance: UIStoryboard {\n        return UIStoryboard(name: self.rawValue, bundle: Bundle.main)\n    }\n\n    func viewController\u003cT: UIViewController\u003e(viewControllerClass: T.Type, function: String = #function, line: Int = #line, file: String = #file) -\u003e T {\n        let storyboardID = (viewControllerClass as UIViewController.Type).storyboardID\n        guard let scene = instance.instantiateViewController(withIdentifier: storyboardID) as? T else {\n            fatalError(\"ViewController with identifier \\(storyboardID), not found in \\(self.rawValue) Storyboard.\\nFile : \\(file) \\nLine Number : \\(line) \\nFunction : \\(function)\")\n        }\n\n        return scene\n    }\n\n    static func initialViewController\u003cT: UIViewController\u003e(viewControllerClass: T.Type, function: String = #function, line: Int = #line, file: String = #file) -\u003e T {\n         let storyboardID = (viewControllerClass as UIViewController.Type).storyboardID\n         guard let scene = UIStoryboard(name: storyboardID, bundle: Bundle.main).instantiateViewController(withIdentifier: storyboardID) as? T else {\n             fatalError(\"ViewController with identifier \\(storyboardID), not found in \\(storyboardID) Storyboard.\\nFile : \\(file) \\nLine Number : \\(line) \\nFunction : \\(function)\")\n         }\n         return scene\n     }\n}\n\nextension UIViewController {\n\n    class var storyboardID: String {\n        return \"\\(self)\"\n    }\n\n    static func instantiate() -\u003e Self {\n        return Storyboard.initialViewController(viewControllerClass: self)\n    }\n}\n```\n\n이제 ViewController를 쉽게 만들 수 있는 능력을 갖게 되었어요. 세팅할 때 더 이상 스토리보드에 의존하지 않아도 돼요. 하지만 스토리보드는 여전히 간단한 디자인을 표시하는 데 유용해요. 그래서 저는 프로젝트에서 그것들을 사용하는 것을 선호해요. 우리 자신의 스토리보드를 만들고 그것들을 코디네이터에 통합함으로써, 유연성과 간단함 사이의 균형을 이룰 수 있어요.\n\n메인 스토리보드 참조를 제거했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 탐색 관리를 위한 MainCoordinator 작성하기\n\n코디네이터 기반의 탐색의 핵심에는 MainCoordinator 개념이 있습니다. 이 코디네이터는 앱의 탐색 계층 구조로의 진입점 역할을 합니다. 필요한 구성 요소를 초기화하고 앱의 초기 상태를 설정하며 사용자를 다양한 화면과 작업 흐름을 통해 안내합니다. 이를 생성해보겠습니다.\n\n```js\nimport UIKit\n\nclass MainCoordinator: Coordinator {\n    var childCoordinators = [Coordinator]()\n    var navigationController: UINavigationController\n    \n    init(navigationController: UINavigationController) {\n        self.navigationController = navigationController\n    }\n    \n    func start() {\n        let vc = InitialViewController.instantiate()\n        vc.coordinator = self\n        navigationController.pushViewController(vc, animated: false)\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 1. Properties:\n\n- `childCoordinators`: An array to keep track of any child coordinators.\n- `navigationController`: A navigation controller used for managing view controllers.\n\n### 2. Initializer:\n\n- It initializes the `MainCoordinator` with a navigation controller.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 시작 메서드:\n\n- 이 방법은 조정 프로세스를 시작하는 데 사용됩니다.\n- InitialViewController를 인스턴스화하고 앱의 시작점을 설정합니다.\n- InitialViewController의 조정자를 자체로 설정합니다.\n- InitialViewController를 네비게이션 스택에 푸시합니다.\n\nSceneDelegate.swift에서 조정자 수동으로 초기화하기\n\n애플리케이션을 위해 조정자를 설정한 후에는 앱이 실행될 때 활성화해야 합니다. 일반적으로 이 초기화는 스토리보드에서 처리하지만, 해당 기능을 비활성화했다면, 이제 SceneDelegate.swift 파일 내에서 직접 시작 프로세스를 관리해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 메인 코디네이터 초기화:\n1. UINavigationController의 인스턴스를 생성합니다.\n2. 이 내비게이션 컨트롤러로 MainCoordinator를 초기화합니다.\n\n### 코디네이터 시작:\n1. 내비게이션 컨트롤러를 윈도우의 루트 뷰 컨트롤러로 할당합니다.\n2. 플로우를 시작하려면 코디네이터의 start() 메서드를 호출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 세련된 구현 방법이 있습니다:\n\n```js\nimport UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    \n    var window: UIWindow?\n    var mainCoordinator: MainCoordinator?\n    \n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        guard let windowScene = (scene as? UIWindowScene) else { return }\n        \n        let navController = UINavigationController()\n        mainCoordinator = MainCoordinator(navigationController: navController)\n        mainCoordinator?.start()\n        \n        window = UIWindow(windowScene: windowScene)\n        window?.rootViewController = navController\n        window?.makeKeyAndVisible()\n    }\n```\n\n간단한 예제로 흐름을 이어보겠습니다;\n\n이를 위해 애플리케이션의 시작점인 InitialViewController에서 이동할 다른 페이지가 필요합니다. 이 간단한 예제에서 RedViewController와 BlueViewController 두 개의 컨트롤러를 만들었습니다. InitialViewController의 두 버튼을 사용하여 이러한 페이지로 이동할 것입니다. 주의해야 할 점은, UIViewController에 대해 작성한 확장을 사용하려면 스토리보드 식별자를 올바르게 지정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫째, 우리 각 뷰 컨트롤러는 그것의 코디네이터와 통신할 방법이 필요합니다. 따라서 ViewController 세 개 모두에 이 속성을 포함하세요.\n\n```swift\nweak var coordinator: MainCoordinator?\n```\n\n메인 코디네이터에서 작성할 두 가지 메서드를 통해 페이지 간에 이동할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nNavigator.py파일에 `navigateToBlue()` 및 `navigateToRed()` 메서드가 정의되어 있습니다. \n\n이 메서드들은 InitialViewController에서 정의한 액션에서 호출됩니다.\n\nInitialViewController에서는 다음과 같이 호출됩니다.\n\n\n   @IBAction func navigateToBlueVC(_ sender: Any) {\n        coordinator?.navigateToBlue()\n    }\n    \n    @IBAction func navigateToRedVC(_ sender: Any) {\n        coordinator?.navigateToRed()\n    }\n\n\n이제 코디네이터가 제어하는 각 뷰 컨트롤러 간에 탐색이 가능한 앱이 작동해야 합니다. 축하합니다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nCoordinator Pattern을 Swift에서 구현하면 iOS 애플리케이션 내에서 네비게이션을 처리하는 구조화되고 유지보수 가능한 방법을 제공합니다. 이 패턴을 사용하면 네비게이션 로직을 뷰 컨트롤러로부터 분리하여 더 깔끔한 코드베이스를 유지할 뿐만 아니라 재사용성을 향상시키고 테스트를 간단하게 만듭니다. 앱이 확장되면 Coordinator Pattern을 통해 네비게이션 아키텍처가 견고하고 적응성이 뛰어나게 유지되어 새로운 기능을 원활하게 통합할 수 있고 개발 프로세스를 더욱 원활하게 만들 수 있습니다. 이 패턴을 받아들이는 것은 더 모듈식이고 조직화된 Swift 애플리케이션으로 가는 한 걸음이며, 이는 최종적으로 더 나은 개발자 경험과 믿을 수 있는 앱을 제공하게 됩니다.","ogImage":{"url":"/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png"},"coverImage":"/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e각 화면을 포함하는 앱은 사용자가 인터페이스를 탐색하고 다른 기능에 액세스할 수 있는 시스템이 필요합니다. 내장된 네비게이션 컨트롤러와 같은 도구를 통해 또는 사용자 정의 솔루션을 통해 이러한 네비게이션을 구현하는 것은 복잡할 수 있습니다. 잘 설계된 네비게이션 구조는 앱의 다른 부분이 독립적이고 유지보수가 쉽도록 보장하여 뷰 컨트롤러 간에 강하게 결합되지 않고 널리 퍼져 있는 종속성을 피합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png\" alt=\"Navigation Structure\"\u003e\u003c/p\u003e\n\u003ch1\u003e문제점은 무엇인가요?\u003c/h1\u003e\n\u003cp\u003eiOS 앱에서 네비게이션을 관리하는 일반적인 방법은 UINavigationController를 사용하는 것입니다. 이 컨트롤러는 뷰 컨트롤러를 푸시하고 팝하여 화면 간의 전환을 원활하고 쉽게 처리합니다. 예를 들어:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 접근 방식을 통해 한 뷰 컨트롤러가 다른 뷰 컨트롤러를 알고 만들고 구성하며 표시하는 역할을 맡게 됩니다. 이는 애플리케이션에서 뷰 컨트롤러 사이의 링크가 하드 코딩되므로 응집력이 높습니다. 결과적으로, 동일한 뷰 컨트롤러를 다른 위치에서 표시해야 한다면 구성 코드를 중복해서 작성해야 할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003eCoordinator 패턴에서는 ViewController가 새로운 ViewController를 만들고 구성하는 역할을 맡은 Coordinator와만 통신합니다. 이 접근 방식은 ViewController들이 서로 분리되어 있으며 이동할 특정 ViewController를 알지 못하도록 보장하기 때문에 더 정리되고 유지보수가 편리한 코드베이스를 유지할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eCoordinator 만들기를 시작해봅시다.\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e두 개의 프로토콜을 생성해야 합니다. 첫 번째 프로토콜은 모든 코디네이터가 따를 기본 구조를 포함할 것입니다. 두 번째 프로토콜은 메인 코디네이터에 특화됩니다. 이 두 번째 프로토콜은 코디네이터와 뷰 컨트롤러 간의 커뮤니케이션을 원활히 할 것입니다.\u003c/p\u003e\n\u003cp\u003eMarkdown 형식으로 위 코드를 조금 수정해주시면 좋을 것 같네요.\u003c/p\u003e\n\u003cp\u003e처음에는 모든 코디네이터가 준수해야 할 Coordinator 프로토콜을 생성해야 합니다. 기본적인 구조를 따르는 것이 좋습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChild Coordinators 속성: 자식 코디네이터를 저장하는 속성을 추가합니다.\u003c/li\u003e\n\u003cli\u003eNavigation Controller 속성: 뷰 컨트롤러를 표시하는 데 사용될 네비게이션 컨트롤러를 보유하는 속성을 포함합니다.\u003c/li\u003e\n\u003cli\u003eStart 메서드: 코디네이터가 제어를 가져갈 수 있도록 start() 메서드를 정의합니다. 이렇게 하면 필요할 때만 코디네이터를 생성하고 활성화할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 ViewController를 만들 수 있는 확장 프로그램을 추가해서 조금 더 쉽게 작업할 수 있게 되었어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUIKit\u003c/span\u003e\n\npublic enum \u003cspan class=\"hljs-title class_\"\u003eStoryboard\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e main = \u003cspan class=\"hljs-string\"\u003e\"Main\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003einstance\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIStoryboard\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUIStoryboard\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: self.\u003cspan class=\"hljs-property\"\u003erawValue\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebundle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBundle\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e)\n    }\n\n    func viewController\u0026#x3C;\u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003eviewControllerClass\u003c/span\u003e: T.\u003cspan class=\"hljs-property\"\u003eType\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003efunction\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = #\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eline\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e = #line, \u003cspan class=\"hljs-attr\"\u003efile\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = #file) -\u003e T {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e storyboardID = (viewControllerClass \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eType\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003estoryboardID\u003c/span\u003e\n        guard \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e scene = instance.\u003cspan class=\"hljs-title function_\"\u003einstantiateViewController\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewithIdentifier\u003c/span\u003e: storyboardID) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e? T \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003efatalError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ViewController with identifier \\(storyboardID), not found in \\(self.rawValue) Storyboard.\\nFile : \\(file) \\nLine Number : \\(line) \\nFunction : \\(function)\"\u003c/span\u003e)\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e scene\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e func initialViewController\u0026#x3C;\u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003eviewControllerClass\u003c/span\u003e: T.\u003cspan class=\"hljs-property\"\u003eType\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003efunction\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = #\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eline\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e = #line, \u003cspan class=\"hljs-attr\"\u003efile\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = #file) -\u003e T {\n         \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e storyboardID = (viewControllerClass \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eType\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003estoryboardID\u003c/span\u003e\n         guard \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e scene = \u003cspan class=\"hljs-title class_\"\u003eUIStoryboard\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: storyboardID, \u003cspan class=\"hljs-attr\"\u003ebundle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBundle\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003einstantiateViewController\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewithIdentifier\u003c/span\u003e: storyboardID) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e? T \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n             \u003cspan class=\"hljs-title function_\"\u003efatalError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ViewController with identifier \\(storyboardID), not found in \\(storyboardID) Storyboard.\\nFile : \\(file) \\nLine Number : \\(line) \\nFunction : \\(function)\"\u003c/span\u003e)\n         }\n         \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e scene\n     }\n}\n\nextension \u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estoryboardID\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\\(self)\"\u003c/span\u003e\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e func \u003cspan class=\"hljs-title function_\"\u003einstantiate\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eSelf\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStoryboard\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitialViewController\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eviewControllerClass\u003c/span\u003e: self)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 ViewController를 쉽게 만들 수 있는 능력을 갖게 되었어요. 세팅할 때 더 이상 스토리보드에 의존하지 않아도 돼요. 하지만 스토리보드는 여전히 간단한 디자인을 표시하는 데 유용해요. 그래서 저는 프로젝트에서 그것들을 사용하는 것을 선호해요. 우리 자신의 스토리보드를 만들고 그것들을 코디네이터에 통합함으로써, 유연성과 간단함 사이의 균형을 이룰 수 있어요.\u003c/p\u003e\n\u003cp\u003e메인 스토리보드 참조를 제거했어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e탐색 관리를 위한 MainCoordinator 작성하기\u003c/h2\u003e\n\u003cp\u003e코디네이터 기반의 탐색의 핵심에는 MainCoordinator 개념이 있습니다. 이 코디네이터는 앱의 탐색 계층 구조로의 진입점 역할을 합니다. 필요한 구성 요소를 초기화하고 앱의 초기 상태를 설정하며 사용자를 다양한 화면과 작업 흐름을 통해 안내합니다. 이를 생성해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUIKit\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMainCoordinator\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCoordinator\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e childCoordinators = [\u003cspan class=\"hljs-title class_\"\u003eCoordinator\u003c/span\u003e]()\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enavigationController\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUINavigationController\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enavigationController: UINavigationController\u003c/span\u003e) {\n        self.\u003cspan class=\"hljs-property\"\u003enavigationController\u003c/span\u003e = navigationController\n    }\n    \n    func \u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e vc = \u003cspan class=\"hljs-title class_\"\u003eInitialViewController\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einstantiate\u003c/span\u003e()\n        vc.\u003cspan class=\"hljs-property\"\u003ecoordinator\u003c/span\u003e = self\n        navigationController.\u003cspan class=\"hljs-title function_\"\u003epushViewController\u003c/span\u003e(vc, \u003cspan class=\"hljs-attr\"\u003eanimated\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch3\u003e1. Properties:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003echildCoordinators\u003c/code\u003e: An array to keep track of any child coordinators.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enavigationController\u003c/code\u003e: A navigation controller used for managing view controllers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2. Initializer:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eIt initializes the \u003ccode\u003eMainCoordinator\u003c/code\u003e with a navigation controller.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e시작 메서드:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e이 방법은 조정 프로세스를 시작하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003eInitialViewController를 인스턴스화하고 앱의 시작점을 설정합니다.\u003c/li\u003e\n\u003cli\u003eInitialViewController의 조정자를 자체로 설정합니다.\u003c/li\u003e\n\u003cli\u003eInitialViewController를 네비게이션 스택에 푸시합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSceneDelegate.swift에서 조정자 수동으로 초기화하기\u003c/p\u003e\n\u003cp\u003e애플리케이션을 위해 조정자를 설정한 후에는 앱이 실행될 때 활성화해야 합니다. 일반적으로 이 초기화는 스토리보드에서 처리하지만, 해당 기능을 비활성화했다면, 이제 SceneDelegate.swift 파일 내에서 직접 시작 프로세스를 관리해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch3\u003e메인 코디네이터 초기화:\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eUINavigationController의 인스턴스를 생성합니다.\u003c/li\u003e\n\u003cli\u003e이 내비게이션 컨트롤러로 MainCoordinator를 초기화합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e코디네이터 시작:\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e내비게이션 컨트롤러를 윈도우의 루트 뷰 컨트롤러로 할당합니다.\u003c/li\u003e\n\u003cli\u003e플로우를 시작하려면 코디네이터의 start() 메서드를 호출합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기 세련된 구현 방법이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUIKit\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSceneDelegate\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIResponder\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eUIWindowSceneDelegate\u003c/span\u003e {\n    \n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewindow\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIWindow\u003c/span\u003e?\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emainCoordinator\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMainCoordinator\u003c/span\u003e?\n    \n    func \u003cspan class=\"hljs-title function_\"\u003escene\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions\u003c/span\u003e) {\n        guard \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e windowScene = (scene \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e? \u003cspan class=\"hljs-title class_\"\u003eUIWindowScene\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e }\n        \n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e navController = \u003cspan class=\"hljs-title class_\"\u003eUINavigationController\u003c/span\u003e()\n        mainCoordinator = \u003cspan class=\"hljs-title class_\"\u003eMainCoordinator\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003enavigationController\u003c/span\u003e: navController)\n        mainCoordinator?.\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e()\n        \n        \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eUIWindow\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewindowScene\u003c/span\u003e: windowScene)\n        \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003erootViewController\u003c/span\u003e = navController\n        \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e?.\u003cspan class=\"hljs-title function_\"\u003emakeKeyAndVisible\u003c/span\u003e()\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e간단한 예제로 흐름을 이어보겠습니다;\u003c/p\u003e\n\u003cp\u003e이를 위해 애플리케이션의 시작점인 InitialViewController에서 이동할 다른 페이지가 필요합니다. 이 간단한 예제에서 RedViewController와 BlueViewController 두 개의 컨트롤러를 만들었습니다. InitialViewController의 두 버튼을 사용하여 이러한 페이지로 이동할 것입니다. 주의해야 할 점은, UIViewController에 대해 작성한 확장을 사용하려면 스토리보드 식별자를 올바르게 지정해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e첫째, 우리 각 뷰 컨트롤러는 그것의 코디네이터와 통신할 방법이 필요합니다. 따라서 ViewController 세 개 모두에 이 속성을 포함하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eweak\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e coordinator: \u003cspan class=\"hljs-type\"\u003eMainCoordinator\u003c/span\u003e?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e메인 코디네이터에서 작성할 두 가지 메서드를 통해 페이지 간에 이동할 수 있을 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eNavigator.py파일에 \u003ccode\u003enavigateToBlue()\u003c/code\u003e 및 \u003ccode\u003enavigateToRed()\u003c/code\u003e 메서드가 정의되어 있습니다.\u003c/p\u003e\n\u003cp\u003e이 메서드들은 InitialViewController에서 정의한 액션에서 호출됩니다.\u003c/p\u003e\n\u003cp\u003eInitialViewController에서는 다음과 같이 호출됩니다.\u003c/p\u003e\n\u003cp\u003e@IBAction func navigateToBlueVC(_ sender: Any) {\ncoordinator?.navigateToBlue()\n}\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@IBAction func navigateToRedVC(_ sender: Any) {\n    coordinator?.navigateToRed()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 코디네이터가 제어하는 각 뷰 컨트롤러 간에 탐색이 가능한 앱이 작동해야 합니다. 축하합니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eCoordinator Pattern을 Swift에서 구현하면 iOS 애플리케이션 내에서 네비게이션을 처리하는 구조화되고 유지보수 가능한 방법을 제공합니다. 이 패턴을 사용하면 네비게이션 로직을 뷰 컨트롤러로부터 분리하여 더 깔끔한 코드베이스를 유지할 뿐만 아니라 재사용성을 향상시키고 테스트를 간단하게 만듭니다. 앱이 확장되면 Coordinator Pattern을 통해 네비게이션 아키텍처가 견고하고 적응성이 뛰어나게 유지되어 새로운 기능을 원활하게 통합할 수 있고 개발 프로세스를 더욱 원활하게 만들 수 있습니다. 이 패턴을 받아들이는 것은 더 모듈식이고 조직화된 Swift 애플리케이션으로 가는 한 걸음이며, 이는 최종적으로 더 나은 개발자 경험과 믿을 수 있는 앱을 제공하게 됩니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-01-NavigationviaCoordinatorPattern"},"buildId":"7hNDOmve0zHk5f26XIl6c","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>