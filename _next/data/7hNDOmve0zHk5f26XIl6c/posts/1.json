{"pageProps":{"posts":[{"title":"애플 iOS 18 업데이트에서 꼭 시도해봐야 할 72가지 기능","description":"","date":"2024-07-01 20:54","slug":"2024-07-01-The72FeaturesOfApplesiOS18UpdateYouNEEDToTry","content":"\n\n**그냥 거침없이 말하자면 — iOS 18는 지금까지 가장 기대되는 애플 업데이트입니다.**\n\n가장 큰 이유는 삼성이 AI(Circle to Search)를 새로운 갤럭시 S24 시리즈에 통합하고 나서입니다. 이것은 애플 팬들을 애플의 미래에 대해 생각하게 만들었다...","ogImage":{"url":"/assets/img/2024-07-01-The72FeaturesOfApplesiOS18UpdateYouNEEDToTry_0.png"},"coverImage":"/assets/img/2024-07-01-The72FeaturesOfApplesiOS18UpdateYouNEEDToTry_0.png","tag":["Tech"],"readingTime":1},{"title":"Coordinator 패턴을 사용한 네비게이션 방법","description":"","date":"2024-07-01 20:53","slug":"2024-07-01-NavigationviaCoordinatorPattern","content":"\n\n각 화면을 포함하는 앱은 사용자가 인터페이스를 탐색하고 다른 기능에 액세스할 수 있는 시스템이 필요합니다. 내장된 네비게이션 컨트롤러와 같은 도구를 통해 또는 사용자 정의 솔루션을 통해 이러한 네비게이션을 구현하는 것은 복잡할 수 있습니다. 잘 설계된 네비게이션 구조는 앱의 다른 부분이 독립적이고 유지보수가 쉽도록 보장하여 뷰 컨트롤러 간에 강하게 결합되지 않고 널리 퍼져 있는 종속성을 피합니다.\n\n![Navigation Structure](/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png)\n\n# 문제점은 무엇인가요?\n\niOS 앱에서 네비게이션을 관리하는 일반적인 방법은 UINavigationController를 사용하는 것입니다. 이 컨트롤러는 뷰 컨트롤러를 푸시하고 팝하여 화면 간의 전환을 원활하고 쉽게 처리합니다. 예를 들어:\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식을 통해 한 뷰 컨트롤러가 다른 뷰 컨트롤러를 알고 만들고 구성하며 표시하는 역할을 맡게 됩니다. 이는 애플리케이션에서 뷰 컨트롤러 사이의 링크가 하드 코딩되므로 응집력이 높습니다. 결과적으로, 동일한 뷰 컨트롤러를 다른 위치에서 표시해야 한다면 구성 코드를 중복해서 작성해야 할 수도 있습니다.\n\nCoordinator 패턴에서는 ViewController가 새로운 ViewController를 만들고 구성하는 역할을 맡은 Coordinator와만 통신합니다. 이 접근 방식은 ViewController들이 서로 분리되어 있으며 이동할 특정 ViewController를 알지 못하도록 보장하기 때문에 더 정리되고 유지보수가 편리한 코드베이스를 유지할 수 있습니다.\n\n# Coordinator 만들기를 시작해봅시다.\n\n<div class=\"content-ad\"></div>\n\n두 개의 프로토콜을 생성해야 합니다. 첫 번째 프로토콜은 모든 코디네이터가 따를 기본 구조를 포함할 것입니다. 두 번째 프로토콜은 메인 코디네이터에 특화됩니다. 이 두 번째 프로토콜은 코디네이터와 뷰 컨트롤러 간의 커뮤니케이션을 원활히 할 것입니다.\n\nMarkdown 형식으로 위 코드를 조금 수정해주시면 좋을 것 같네요.\n\n처음에는 모든 코디네이터가 준수해야 할 Coordinator 프로토콜을 생성해야 합니다. 기본적인 구조를 따르는 것이 좋습니다:\n\n- Child Coordinators 속성: 자식 코디네이터를 저장하는 속성을 추가합니다.\n- Navigation Controller 속성: 뷰 컨트롤러를 표시하는 데 사용될 네비게이션 컨트롤러를 보유하는 속성을 포함합니다.\n- Start 메서드: 코디네이터가 제어를 가져갈 수 있도록 start() 메서드를 정의합니다. 이렇게 하면 필요할 때만 코디네이터를 생성하고 활성화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 ViewController를 만들 수 있는 확장 프로그램을 추가해서 조금 더 쉽게 작업할 수 있게 되었어요.\n\n```js\nimport UIKit\n\npublic enum Storyboard: String {\n    case main = \"Main\"\n\n    var instance: UIStoryboard {\n        return UIStoryboard(name: self.rawValue, bundle: Bundle.main)\n    }\n\n    func viewController<T: UIViewController>(viewControllerClass: T.Type, function: String = #function, line: Int = #line, file: String = #file) -> T {\n        let storyboardID = (viewControllerClass as UIViewController.Type).storyboardID\n        guard let scene = instance.instantiateViewController(withIdentifier: storyboardID) as? T else {\n            fatalError(\"ViewController with identifier \\(storyboardID), not found in \\(self.rawValue) Storyboard.\\nFile : \\(file) \\nLine Number : \\(line) \\nFunction : \\(function)\")\n        }\n\n        return scene\n    }\n\n    static func initialViewController<T: UIViewController>(viewControllerClass: T.Type, function: String = #function, line: Int = #line, file: String = #file) -> T {\n         let storyboardID = (viewControllerClass as UIViewController.Type).storyboardID\n         guard let scene = UIStoryboard(name: storyboardID, bundle: Bundle.main).instantiateViewController(withIdentifier: storyboardID) as? T else {\n             fatalError(\"ViewController with identifier \\(storyboardID), not found in \\(storyboardID) Storyboard.\\nFile : \\(file) \\nLine Number : \\(line) \\nFunction : \\(function)\")\n         }\n         return scene\n     }\n}\n\nextension UIViewController {\n\n    class var storyboardID: String {\n        return \"\\(self)\"\n    }\n\n    static func instantiate() -> Self {\n        return Storyboard.initialViewController(viewControllerClass: self)\n    }\n}\n```\n\n이제 ViewController를 쉽게 만들 수 있는 능력을 갖게 되었어요. 세팅할 때 더 이상 스토리보드에 의존하지 않아도 돼요. 하지만 스토리보드는 여전히 간단한 디자인을 표시하는 데 유용해요. 그래서 저는 프로젝트에서 그것들을 사용하는 것을 선호해요. 우리 자신의 스토리보드를 만들고 그것들을 코디네이터에 통합함으로써, 유연성과 간단함 사이의 균형을 이룰 수 있어요.\n\n메인 스토리보드 참조를 제거했어요.\n\n<div class=\"content-ad\"></div>\n\n## 탐색 관리를 위한 MainCoordinator 작성하기\n\n코디네이터 기반의 탐색의 핵심에는 MainCoordinator 개념이 있습니다. 이 코디네이터는 앱의 탐색 계층 구조로의 진입점 역할을 합니다. 필요한 구성 요소를 초기화하고 앱의 초기 상태를 설정하며 사용자를 다양한 화면과 작업 흐름을 통해 안내합니다. 이를 생성해보겠습니다.\n\n```js\nimport UIKit\n\nclass MainCoordinator: Coordinator {\n    var childCoordinators = [Coordinator]()\n    var navigationController: UINavigationController\n    \n    init(navigationController: UINavigationController) {\n        self.navigationController = navigationController\n    }\n    \n    func start() {\n        let vc = InitialViewController.instantiate()\n        vc.coordinator = self\n        navigationController.pushViewController(vc, animated: false)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n### 1. Properties:\n\n- `childCoordinators`: An array to keep track of any child coordinators.\n- `navigationController`: A navigation controller used for managing view controllers.\n\n### 2. Initializer:\n\n- It initializes the `MainCoordinator` with a navigation controller.\n\n<div class=\"content-ad\"></div>\n\n3. 시작 메서드:\n\n- 이 방법은 조정 프로세스를 시작하는 데 사용됩니다.\n- InitialViewController를 인스턴스화하고 앱의 시작점을 설정합니다.\n- InitialViewController의 조정자를 자체로 설정합니다.\n- InitialViewController를 네비게이션 스택에 푸시합니다.\n\nSceneDelegate.swift에서 조정자 수동으로 초기화하기\n\n애플리케이션을 위해 조정자를 설정한 후에는 앱이 실행될 때 활성화해야 합니다. 일반적으로 이 초기화는 스토리보드에서 처리하지만, 해당 기능을 비활성화했다면, 이제 SceneDelegate.swift 파일 내에서 직접 시작 프로세스를 관리해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n### 메인 코디네이터 초기화:\n1. UINavigationController의 인스턴스를 생성합니다.\n2. 이 내비게이션 컨트롤러로 MainCoordinator를 초기화합니다.\n\n### 코디네이터 시작:\n1. 내비게이션 컨트롤러를 윈도우의 루트 뷰 컨트롤러로 할당합니다.\n2. 플로우를 시작하려면 코디네이터의 start() 메서드를 호출합니다.\n\n<div class=\"content-ad\"></div>\n\n여기 세련된 구현 방법이 있습니다:\n\n```js\nimport UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n    \n    var window: UIWindow?\n    var mainCoordinator: MainCoordinator?\n    \n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        guard let windowScene = (scene as? UIWindowScene) else { return }\n        \n        let navController = UINavigationController()\n        mainCoordinator = MainCoordinator(navigationController: navController)\n        mainCoordinator?.start()\n        \n        window = UIWindow(windowScene: windowScene)\n        window?.rootViewController = navController\n        window?.makeKeyAndVisible()\n    }\n```\n\n간단한 예제로 흐름을 이어보겠습니다;\n\n이를 위해 애플리케이션의 시작점인 InitialViewController에서 이동할 다른 페이지가 필요합니다. 이 간단한 예제에서 RedViewController와 BlueViewController 두 개의 컨트롤러를 만들었습니다. InitialViewController의 두 버튼을 사용하여 이러한 페이지로 이동할 것입니다. 주의해야 할 점은, UIViewController에 대해 작성한 확장을 사용하려면 스토리보드 식별자를 올바르게 지정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n첫째, 우리 각 뷰 컨트롤러는 그것의 코디네이터와 통신할 방법이 필요합니다. 따라서 ViewController 세 개 모두에 이 속성을 포함하세요.\n\n```swift\nweak var coordinator: MainCoordinator?\n```\n\n메인 코디네이터에서 작성할 두 가지 메서드를 통해 페이지 간에 이동할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\nNavigator.py파일에 `navigateToBlue()` 및 `navigateToRed()` 메서드가 정의되어 있습니다. \n\n이 메서드들은 InitialViewController에서 정의한 액션에서 호출됩니다.\n\nInitialViewController에서는 다음과 같이 호출됩니다.\n\n\n   @IBAction func navigateToBlueVC(_ sender: Any) {\n        coordinator?.navigateToBlue()\n    }\n    \n    @IBAction func navigateToRedVC(_ sender: Any) {\n        coordinator?.navigateToRed()\n    }\n\n\n이제 코디네이터가 제어하는 각 뷰 컨트롤러 간에 탐색이 가능한 앱이 작동해야 합니다. 축하합니다!\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nCoordinator Pattern을 Swift에서 구현하면 iOS 애플리케이션 내에서 네비게이션을 처리하는 구조화되고 유지보수 가능한 방법을 제공합니다. 이 패턴을 사용하면 네비게이션 로직을 뷰 컨트롤러로부터 분리하여 더 깔끔한 코드베이스를 유지할 뿐만 아니라 재사용성을 향상시키고 테스트를 간단하게 만듭니다. 앱이 확장되면 Coordinator Pattern을 통해 네비게이션 아키텍처가 견고하고 적응성이 뛰어나게 유지되어 새로운 기능을 원활하게 통합할 수 있고 개발 프로세스를 더욱 원활하게 만들 수 있습니다. 이 패턴을 받아들이는 것은 더 모듈식이고 조직화된 Swift 애플리케이션으로 가는 한 걸음이며, 이는 최종적으로 더 나은 개발자 경험과 믿을 수 있는 앱을 제공하게 됩니다.","ogImage":{"url":"/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png"},"coverImage":"/assets/img/2024-07-01-NavigationviaCoordinatorPattern_0.png","tag":["Tech"],"readingTime":8},{"title":"iOS에서 에뮬레이션하는 방법 가이드","description":"","date":"2024-07-01 20:52","slug":"2024-07-01-AGuidetoEmulationoniOS","content":"\n\n![Emulation on iOS](/assets/img/2024-07-01-AGuidetoEmulationoniOS_0.png)\n\n안녕하세요! iOS에서 에뮬레이터는 요즘 핫한 주제입니다. 유럽 연합의 관문 규제법이 애플 앱스토어 제한을 완화하는 파급 효과를 냈으며 전 세계적으로 사용자들에게 더 다양한 응용프로그램을 선택할 수 있게 해주었습니다. 새로운 각 에뮬레이터는 전 세대 비디오 게임 클래식을 다시 발견하는 새로운 고객군을 선사하며 차트를 석권하고 있습니다.","ogImage":{"url":"/assets/img/2024-07-01-AGuidetoEmulationoniOS_0.png"},"coverImage":"/assets/img/2024-07-01-AGuidetoEmulationoniOS_0.png","tag":["Tech"],"readingTime":1},{"title":"iOS 기술 스택 주간 업데이트  제131호","description":"","date":"2024-07-01 20:51","slug":"2024-07-01-iOSStackWeeklyIssue131","content":"\n\n마크다운 형식으로 이미지를 수정해보겠어요.\n\n![iOSStackWeeklyIssue131_0](/assets/img/2024-07-01-iOSStackWeeklyIssue131_0.png)\n\n# 기사\n\n## Swift 6.0에서 무슨 변화가 있을까요?\n\n2024년은 Swift의 10주년이며, 이 중 5년은 주요 버전의 Swift 업데이트가 없었습니다. Swift의 수명의 절반을 5.0 이상의 버전으로 보낸 셈이에요.\n\n<div class=\"content-ad\"></div>\n\n## 스위프트 테스팅 시작하기\n\n이 글에서는 Swift 테스팅을 시작하는 방법, 테스트 작성 방법, 기존의 XCTest 테스트를 새 라이브러리로 이전하는 방법에 대해 알아보겠습니다.\n\n## Swift를 사용하여 iOS에 강력한 네트워크 레이어 구축하기\n\n이 글은 제공된 코드를 기반으로 Swift를 사용하여 강력한 네트워크 레이어를 만드는 방법을 안내합니다.\n\n<div class=\"content-ad\"></div>\n\n## 서로 다른 스택에 있는 뷰들을 SwiftUI에서 정렬하는 방법\n\nSwiftUI 뷰를 작업할 때, 서로 다른 스택에 있는 뷰들을 가운데 정렬할 수 있는 방법이 필요했습니다.\n\n## SwiftUI ScrollView: 항목 가시성 확인 및 필요에 따라 더 로드\n\n이 기사에서는 ScrollView 내에서 항목 가시성을 확인하고 맨 위 또는 맨 아래에 있을 때 더 많은 항목을 로드하는 방법을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## SwiftUI Hero Animations with NavigationTransition\n\n이 글에서는 App Store의 Today view와 유사한 히어로 애니메이션을 구현하는 방법을 배워보겠습니다.\n\n## Swift 6: Xcode 프로젝트 및 패키지를 점진적으로 이식하는 방법\n\nApple은 프로그래밍 언어의 주요 릴리스로 Swift 6을 WWDC 2024에서 발표했습니다. 이 글에서는 Xcode 프로젝트 및 패키지를 Swift 6로 점진적으로 이식하는 방법을 배우겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Sponsored\n\n# Video\n\n## WWDC24: 앱에 표현력 더하기 - Genmoji로 시작하세요\n\nGenmoji를 사용하여 앱에서 어떻게 표현력을 더할 수 있는지 알아보세요. Genmoji를 포함한 텍스트를 렌더링, 저장 및 통신하는 방법을 살펴보겠습니다. 앱에 사용자 지정 텍스트 엔진이 있는 경우, Genmoji를 지원하는 기술도 다룰 예정입니다. 🌟\n\n<div class=\"content-ad\"></div>\n\n# 다가오는 주간을 위한 링크 건의\n\n제안과 피드백을 환영합니다!\n\n당사의 다음 주간에 고려할 내용 또는 피드백이 있으실 경우 Canopas의 트위터 핸들 @canopas_eng로 연락해 주시기 바랍니다.","ogImage":{"url":"/assets/img/2024-07-01-iOSStackWeeklyIssue131_0.png"},"coverImage":"/assets/img/2024-07-01-iOSStackWeeklyIssue131_0.png","tag":["Tech"],"readingTime":2},{"title":"안드로이드 스택 주간 소식  제131호","description":"","date":"2024-07-01 20:50","slug":"2024-07-01-AndroidStackWeeklyIssue131","content":"\n\n![Image](/assets/img/2024-07-01-AndroidStackWeeklyIssue131_0.png)\n\n# 글\n\n## Compose Multiplatform으로 시작하기: 단계별 가이드\n\nKotlin의 Compose Multiplatform UI 프레임워크를 사용하여 크로스 플랫폼 앱을 만드는 방법을 배워보세요. 이 가이드는 Android, iOS, 데스크톱 및 웹을 위한 콤포저블, 레이아웃, 이벤트 및 수정자의 기본 사항을 다룹니다.\n\n<div class=\"content-ad\"></div>\n\n## 모바일 애플리케이션을 위한 최고의 Firebase 도구들\n\n모바일 앱을 향상시키기 위한 필수적인 Firebase 도구들을 발견해보세요. 분석, 클라우드 메시징, 인증, 그리고 실시간 데이터베이스를 포함하여 최적의 성능과 사용자 참여를 보장합니다.\n\n## 안드로이드에서 코루틴 활용: 동시성 필수 요소\n\n효율적인 동시성을 위해 안드로이드 코루틴을 마스터해보세요. 핵심 개념, 실용적인 예제, 그리고 최고의 실행 방법을 배워 앱의 성능과 응답성을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 플레이 코어 라이브러리에서의 이주: 포괄적인 안내\n\n플레이 코어 라이브러리에서 최신 버전으로의 원활한 전환 방법을 배워보세요. 주요 변경 사항, 최선의 실천 방법 및 원활한 이주를 위한 필수 단계를 다루고 있습니다.\n\n## 작은 일들: 프로그래밍에서 혼란스러운 오류 메시지\n\n프로그래밍에서 혼란스러운 오류 메시지가 개발자를 오도할 수 있는 흔한 함정을 탐험해보세요. 이 게시물은 안드로이드의 Jetpack Compose를 사용한 실제 예제를 공유하며 도전에 대해 강조하고 간단한 해결책을 제시합니다.\n\n<div class=\"content-ad\"></div>\n\n# 후원\n\n# 라이브러리 & 자료\n\n## LuckyWheelView\n\nKotlin으로 개발된 Lucky Wheel을 표시하는 사용자 정의 경량 구성 요소입니다.\n\n<div class=\"content-ad\"></div>\n\n## 드롭다운\n\n강력하고 사용자 정의 가능한 Compose Multiplatform 드롭다운 메뉴로, 계층 구조 및 애니메이션을 적용할 수 있습니다.\n\n## 뉴스-KMP-앱\n\n안드로이드, iOS, Windows, macOS, Linux 플랫폼을 대상으로 하는 뉴스 Kotlin Multiplatform 프로젝트입니다.\n\n<div class=\"content-ad\"></div>\n\n# 비디오\n\n## 데이터프레임: 코틀린의 혁신적인 데이터 구조 접근 | 로만 벨로프\n\n## 인공지능과 코틀린: 완벽한 조합 | 블라디슬라프 탄코프\n\n## 코틀린 표준 라이브러리의 놓칠 수 있는 7가지 기능\n\n<div class=\"content-ad\"></div>\n\n## 콘시스트로 코틀린 코드베이스의 일관성 유지하기!\n\n## 코틀린 멀티플랫폼에서 리소스 공유하는 방법 — 초심자를 위한 KMP\n\n## 코인을 활용한 코틀린 Mutex를 이용한 의존성 주입 전체 가이드 — 초심자를 위한 KMP\n\n## 코틀린 Mutex로 동기화된 병행성 및 스레드 안전성에 대한 궁극의 안내서\n\n<div class=\"content-ad\"></div>\n\n## 다가오는 주간을 위한 링크를 제안합니다\n\n제안과 피드백은 언제든 환영합니다!\n\n당사 Canopas 트위터 핸들인 @canopas_eng로 콘텐츠 또는 피드백을 보내주시면, 다음 주간에서 고려해 보겠습니다.","ogImage":{"url":"/assets/img/2024-07-01-AndroidStackWeeklyIssue131_0.png"},"coverImage":"/assets/img/2024-07-01-AndroidStackWeeklyIssue131_0.png","tag":["Tech"],"readingTime":2},{"title":"코루틴, RxJava, Executor 중 어떤 것이 더 빠르고 어떤 작업에 적합한가","description":"","date":"2024-07-01 20:47","slug":"2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor","content":"\n\n<img src=\"/assets/img/2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png\" />\n\n에버 원더했던 적 있나요? 어떤 멀티스레딩 프레임워크가 빠른지 궁금했던 적이 가끔 있었어요. 어느 날, 운명이 나를 이 질문을 조사하게 이끌었죠. 그래서 여러분도 궁금하다면, 저는 그것들을 테스트하고 비교해본 후 결과를 공유하려고 해요.\n\n# 문제\n\n먼저, 이 일을 왜 했는지 알아보겠어요. 저는 간단한 작업을 마주하게 되었어요: 여러 개의 콜백을 호출하는 시스템이 있었죠. 모든 콜백은 가능한 빨리 완료되어야 했어요.\n\n<div class=\"content-ad\"></div>\n\nSorry for the confusion but could you please provide the text that needs to be translated into Korean?\n\n<div class=\"content-ad\"></div>\n\n어떤 테스트는 Rx와 Coroutines와 같은 두 기술을 비교하는 간단한 테스트들이었고, 다른 것들은 내 의견으로는 너무 구체적인 테스트 케이스를 가졌어요. 예를 들어, 단순 산술 연산이나 데이터베이스 요청만을 테스트하는 것과 같은 것들이 그랬죠. \n\n어쨌든, 이에 대해 너무 만족스럽지 않았고, 제가 직접 테스트를 해보기로 결정했어요. \n\n멀티스레드 프레임워크의 모든 사용 사례를 다 다룰 수 없다는 건 이해해요. 제 업무와 관련된 것들만 테스트할 거예요... 그래서 100% 완벽한 테스트는 아니지만 상당히 철저하게 할 거예요.\n\n## 도구들\n\n<div class=\"content-ad\"></div>\n\n자, 마법사들! 이번에는 측정 도구에 대해 이야기해볼게. 안드로이드 개발자로서 안드로이드 도구를 사용해볼 거야. 이론적으로는 컴퓨터에서 JVM에서 멀티스레딩 테스트를 실행하는 것과 안드로이드 기기에서 실행하는 것은 조금 차이가 있을 수 있어. 하지만 실제로는 큰 차이가 없고 전체 테스트 결과에 영향을 미치지 않아.\n\n그리고, 안드로이드 기기에서 코드 성능을 테스트할 수 있는 젯팩 마이크로벤치마크 도구도 있어.\n\n마이크로벤치마크 측정 테스트는 평범한 인스트루멘테이션 테스트와 비슷한데, 특정한 Rule인 벤치마크룰을 사용한다는 점만 다를 뿐이야.\n\n```kotlin\n@get:Rule\nval benchmarkRule = BenchmarkRule()\n\n@Test\nfun sampleTest() {\n   benchmarkRule.measureRepeated {\n       // 우리가 이걸 측정할 거야\n   }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그 결과, 실행에 대한 정보를 포함한 JSON을 얻습니다. 최소 및 최대 시간과 무엇보다 중앙값 시간이 포함되어 있습니다.\n\n```json\n    \"benchmarks\": [\n        {\n            \"name\": \"sampleTest\",\n            \"params\": {},\n            \"className\": \"com.test.benchmark.ExampleBenchmark\",\n            \"totalRunTimeNs\": 85207217833,\n            \"metrics\": {\n                \"timeNs\": {\n                    \"minimum\": 9.82149833E8,\n                    \"maximum\": 1.019338584E9,\n                    \"median\": 1.004151917E9,\n                    \"runs\": [...]\n                },\n                \"allocationCount\": {\n                    \"minimum\": 324.0,\n                    \"maximum\": 324.0,\n                    \"median\": 324.0,\n                    \"runs\": [...]\n                }\n            },\n            \"sampledMetrics\": {},\n            \"warmupIterations\": 3200,\n            \"repeatIterations\": 5000,\n            \"thermalThrottleSleepSeconds\": 0\n        }\n    ]\n```\n\n이 JSON에는 반복 횟수, 객체 할당 횟수 등 다른 정보가 포함되어 있습니다. 현재로서는 우리에게 중요하지는 않습니다.\n\n# 벤치마크 테스트 케이스\n\n<div class=\"content-ad\"></div>\n\n프레임워크 간의 주요 차이점은:\n\n- 프레임워크가 단일 스레드를 생성하는 데 걸리는 시간;\n- 프레임워크가 작업을 효율적으로 빠르게 스레드 간에 분배하는 능력.\n\n이러한 프레임워크 간의 차이를 평가하기 위해 테스트 케이스 결과를 탐색합니다.\n\n이제 우리는 무엇을 테스트할지 결정해야 합니다. 테스트 데이터부터 시작해 보죠.\n\n<div class=\"content-ad\"></div>\n\n# 테스트 데이터\n\n이건 별거 아니에요. 0부터 99까지의 100개 항목을 가진 ArrayList를 만들 거예요.\n\n```kotlin\nprivate fun createTestList(): List<Int> {\n   return List(100) { it }\n}\n```\n\n그리고 각 항목에 대해 몇 가지 작업을 수행할 거예요.\n\n<div class=\"content-ad\"></div>\n\n이제 테스트 케이스를 살펴보겠습니다.\n\n# 단일 스레드\n\n단일 스레드 테스트 케이스부터 시작해봅시다. 이러한 테스트 케이스의 결과를 비교할 때, 각 프레임워크 간의 첫 번째 차이점인 단일 스레드를 생성하는 데 걸리는 시간을 신중하게 살펴보겠습니다. 한 스레드만 있는 경우, 프레임워크가 스레드를 초기화하고 생성하는 데 걸리는 시간을 확인할 수 있습니다.\n\n## 직접 호출\n\n<div class=\"content-ad\"></div>\n\n**첫 번째 테스트 케이스**에서는 메서드를 직접 호출하는 것으로 진행할 거예요. 어떤 프레임워크도 사용하지 않습니다.\n\n```kotlin\n@Test\nfun directInvoke() {\n   val list = createTestList()\n   benchmarkRule.measureRepeated {\n       list.forEach { action(it) }\n   }\n}\n```\n\n## RxJava\n\n두 번째 테스트 케이스에서는 Rx를 사용할 거예요. **Completable** 내에서 작업을 수행할 거예요. 각 작업마다 별도의 **Completable**이 생성될 거예요. 스케줄러는 **Scheduler.single**이 될 거예요. 이를 통해 모든 작업을 단일 스레드에서 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 완료를 기다려야하기 때문에, 결과 Completable에 blockingAwait를 호출할 것입니다.\n\n```kotlin\n@Test\nfun rxOne() {\n   val list = createTestList()\n   val scheduler = Schedulers.single()\n   benchmarkRule.measureRepeated {\n       val completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}  \n```\n\n## Kotlin 코루틴\n\n젊고 유망한 Kotlin 코루틴 프레임워크 없이 어디에 있었을까요? 코루틴을 실행하기 위해 await를 통해 코루틴의 완료를 기다리려면 async를 통해 동작을 실행할 것입니다. 따라서 각 작업에 대해 별도의 코루틴이 있을 것입니다. 모든 것이 단일 스레드에서 실행되게 하려면, 간단히 runBlocking을 사용하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Test\nfun coroutineOne() {\n   val list = createTestList()\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   action(it)\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n## Kotlin Flow\n\nLet’s also consider Flow in comparison. Directly comparing coroutines and Rx may not be the best approach, as both technologies are used in different ways and employ different concepts, despite their association with multithreading.\n\nWe create one flow for each action, combine them all together, and then simply collect them. There will be a separate Flow for each action. Meanwhile, we don’t specify Dispatcher anywhere, so everything happens on the same thread.\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Test\nfun flowOne() {\n    val list = createTestList()\n    benchmarkRule.measureRepeated {\n        runBlocking {\n            val flows = list.map {\n                flow {\n                    val result = action(it)\n                    emit(result)\n                }\n            }\n            flows.merge().collect()\n        }\n    }\n}\n```\n\n## 스레드의 수는 CPU 스레드의 수와 같다\n\n한 스레드만 사용하는 것은 다중 스레딩을 위한 프레임워크가 있는 상황에서 최선의 선택으로 보이지 않습니다.\n\n스레드 풀의 스레드 수가 CPU 스레드 수와 동일한 상황을 고려해보겠습니다. 이 테스트 케이스의 결과를 비교함으로써 두 번째 차이점인 프레임워크가 작업을 효율적이고 빠르게 스레드 간에 분배할 수 있는 능력을 볼 수 있습니다. 각 작업에 충분한 스레드가 없기 때문에 프레임워크는 어차피 작업을 분배해야 할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n프로세서 코어 간 작업이 고르게 분배될 것이라고 기대해서는 안 됩니다. 운영 체제와 CPU가 결정하는 것은:\n\n- 어떤 작업이 실행될 것인지,\n- 언제 실행될 것인지,\n- 누가 실행할지입니다.\n\n현대의 \"큰\" CPU는 SMT/HyperThreading을 사용하여 각 CPU 코어에 여러 논리적 스레드를 만들 수 있습니다. CPU 코어는 독립적으로 명령을 실행할 수 있는 물리적 단위입니다. 반면 스레드는 단일 코어에서 실행할 수 있는 논리적인 소프트웨어 단위입니다. 또한 모바일 CPU 및 최신 Intel CPU는 서로 다른 유형의 CPU 코어를 사용하는 방식을 채택하고 있습니다. 대형 코어는 복잡한 작업에 적합하며, 중간 및 절전 코어는 성능이 크게 다릅니다.\n\n그래서 이 묶음을 적은 수의 스레드를 가진 풀로 생각할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 CPU 스레드 수를 결정하는 탁월한 방법이 있어요:\n\n```java\nRuntime.getRuntime().availableProcessors()\n```\n\n저의 테스트 기기에서는 이 값이 여덟인데요.\n\n## RxJava\n\n<div class=\"content-ad\"></div>\n\n우선 Rx부터 시작해봅시다. Rx는 Scheduler.Computation을 사용하여 원하는 동작을 구현합니다. 실제로 코드는 단일 스레드를 사용하는 것과 동일합니다. 달라지는 것은 각 개별 Completable에 대해 Scheduler.computation()을 사용하는 점 뿐입니다.\n\n```kotlin\n@Test\nfun rxCPU() {\n   val list = createTestList()\n   val scheduler = Schedulers.computation()\n   benchmarkRule.measureRepeated {\n       val completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n```\n\n## 코틀린 코루틴\n\n이제 코루틴을 살펴보겠습니다. 코루틴은 Dispatchers.Default를 사용합니다. Dispatchers.Default에 대한 설명은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n그럼, “병렬성”의 최대 레벨은 기본적으로 CPU 코어의 수와 동일합니다. 바로 필요한 것과 일치하죠.\n\n이 코드는 단일 코어 버전과 유사합니다. 이제 작업은 Dispatchers.Default와 함께 withContext 내에서 실행됩니다.\n\n```kotlin\n@Test\nfun coroutineCPU() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.Default\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   withContext(dispatcher) {\n                       action(it)\n                   }\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n하지만 중요한 세부 사항이 있어요… Dispatchers.Default를 자세히 살펴보면 이 생성자를 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n**DefaultScheduler**이라는 내부 객체가 정의되어 있습니다. 이 객체는 스케줄러 코루틴 디스패처를 만들기 위해 두 개의 상수를 전달한다는 점이 의심스럽습니다: **CORE_POOL_SIZE**, 이 경우 CPU 스레드 수에 해당하며, **MAX_POOL_SIZE**, 그리고 이 값은 두 백만입니다.\n\n더 자세히 살펴보면 이러한 변수들이 **CoroutineScheduler**를 만들기 위해 사용된다는 것을 알 수 있습니다.\n\n```kotlin\nprivate fun createScheduler() = CoroutineScheduler(\n  corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName\n)\n```\n\n<div class=\"content-ad\"></div>\n\n요즘 문서에는 이렇게 써 있어요:\n\nDispatchers.Default는 CPU 스레드의 수에 제한받지 않는다는 걸 보여줍니다.\n\nDispatchers.Default와 Scheduler.Computation을 직접적으로 비교하는 것은 잘못되어요. 때로는 Dispatchers.Default가 추가적인 스레드를 사용할 수도 있어요. 다행히도 문서에는 두 개를 더 공평하게 비교하는 방법에 대한 정보도 제공되어 있어요. 이를 위해 LimitingDispatcher를 사용하면 됩니다. Dispatchers.Default의 limitedParallelism 메서드를 호출할 때 CPU 스레드 수를 함께 지정해주면 돼요.\n\n```kotlin\n@Test\nfun coroutineCPULimit() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val dispatcher = Dispatchers.Default.limitedParallelism(threadCount)\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   withContext(dispatcher) {\n                       action(it)\n                   }\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 코틀린 Flow\n\n플로우에 대해 같은 작업을 수행해 보겠습니다. Dispatchers.Default를 사용하세요.\n\n```kotlin\n@Test\nfun flowCPU() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.Default\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }.flowOn(dispatcher)\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n그리고 Dispatchers.Default를 제한하여 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Test\nfun flowCPULimit() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val dispatcher = Dispatchers.Default.limitedParallelism(threadCount)\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }.flowOn(dispatcher)\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n## Java Executor\n\n우리는 코루틴의 복잡성을 모두 탐색해야 했기 때문에, 이런 복잡성들을 사용해보는 건 어떨까요? 그래서 우리는 Executor를 사용해보려고 합니다.\n\n우선 Executors.newFixedThreadPool을 사용하여 Executor를 생성해 봅시다. 이것은 단순히 CPU 코어의 수에 의해 제한된 Executor를 생성합니다. 이 경우에는 CPU 코어의 수가 됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n기존 measureRepeated 전에는 Executor를 생성하므로 Executor를 만드는 것이 간단한 작업이 아닙니다. 그런 다음, 작업과 함께 Executor에서 submit을 호출합니다. 완료를 기다리기 위해 get 메서드를 사용합시다.\n\n```kotlin\n@Test\nfun executorFixedCPU() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val executorService = Executors.newFixedThreadPool(threadCount)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\nExecutors.newWorkStealingPool 메서드를 사용하여 더 흥미로운 두 번째 유형의 Executor를 만들 것입니다. 실제로 지금은 일정한 수의 스레드를 가진 Executor를 만듭니다. 그러나 메서드 이름에 \"Stealing\"이라는 단어가 단순한 우연은 아닙니다. 이 Executor의 스레드는 현재 스레드가 비어 있고 다른 스레드에 대기 중인 작업이 있을 때 해당 스레드에서 작업을 훔칠 수 있습니다. 이를 통해 공통 대기열을 정리하는 데 도움이 될 수 있습니다.\n\n코드 측면에서는 모든 것이 이전과 동일합니다. Executor를 만드는 방법만 다를 뿐입니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Test\nfun executorStealCPU() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val executorService = Executors.newWorkStealingPool(threadCount)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\n# 한 번에 한 쓰레드\n\n이제 무제한의 (사실 무한은 아니고 그냥 많은) 쓰레드를 할당하는 가능성을 탐색해봅시다. 우리에겐 100개의 액션이 있으니, 실제로 100개의 쓰레드를 할당할 수 있습니다. 그 이상은 필요하지 않죠.\n\n## RxJava\n\n\n<div class=\"content-ad\"></div>\n\nRx를 우선 살펴보겠습니다. `Scheduler.io`는 이러한 업무를 담당합니다. `Scheduler.io`에는 스레드 캐시가 있습니다. 만약 사용 가능한 빈 스레드가 있는 경우 캐시에서 하나를 가져옵니다. 그렇지 않으면 새 스레드를 생성합니다. 코드는 `Scheduler.computation`와 동일하지만 다른 스케줄러를 사용합니다.\n\n```kotlin\n@Test\nfun rxIo() {\n   val list = createTestList()\n   val scheduler = Schedulers.io()\n   benchmarkRule.measureRepeated {\n       val completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n```\n\n## Kotlin 코루틴\n\n코루틴에서 유사한 작업은 `Dispatchers.IO`의 역할이며, 우리는 익숙한 코드에 그냥 삽입하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n@test\n간접 조건을 조정하십시오. 더 많은 정보가 필요한 경우 도와 드리겠습니다 :)\n\n\n<div class=\"content-ad\"></div>\n\n## Java Executor\n\n포루투니티로 Executor는 아주 멋진 API를 갖고 있지 않아요. 그래서 여기에 백 개의 스레드를 할당해 줄 거에요. 액션이 백 개밖에 없으니까, 그 이상의 스레드는 필요 없을 거에요.\n\n\n@Test\nfun executorFixedIo() {\n   val list = createTestList()\n   val executorService = Executors.newFixedThreadPool(100)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n\n\nnewWorkStealingPool을 위해서도 똑같이 할 거에요.\n\n<div class=\"content-ad\"></div>\n\n이것은 모든 프레임워크의 테스트 케이스 표입니다.\n\n![테스트 케이스 표](/assets/img/2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_1.png)\n\n그리고 마지막으로, 테스트를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n# 테스트\n\n하하, 조금 속였죠. 먼저, 행동의 범주를 고려해 봅시다.\n\n총 다섯 가지 범주가 있습니다:\n\n- 산술 — 간단한 산술 연산;\n- 목록조작 — 객체 조작;\n- 저장소 — 저장소 작업 시뮬레이션;\n- 네트워크 — 네트워크 작업 시뮬레이션;\n- 혼합 — 모든 이전 스크립트의 조합, 원본 작업에서 행동이 얼마나 어려울지 모르기 때문에.\n\n<div class=\"content-ad\"></div>\n\n간단하게 시작해봅시다.\n\n# 산술\n\n각 항목에 대해 0부터 99까지의 작업을 수행할 것임을 상기시키고 싶습니다. 이 경우, 연산을 조금 더 복잡하게 만들기 위해 숫자를 실수로 변환하고 해당 숫자의 제곱으로 올려야 합니다. 0의 제곱부터 99의 제곱까지. 물론 어느 시점에서는 실수의 한계에 도달할 수도 있지만, 괜찮습니다.\n\n```kotlin\nfun arithmetic(seed: Int): Int {\n    return seed.toFloat().pow(seed.toFloat()).toInt()\n}\n```\n\n<div class=\"content-ad\"></div>\n\n일반적으로, 이 범주로 분류할 수 있는 작업에는 생성자를 사용하여 객체를 만들거나 속성에 액세스하는 것이 포함됩니다. 이러한 작업은 완료하는 데 오랜 시간이 걸리지 않습니다.\n\n결과는 무엇인가요?\n\n![Image](/assets/img/2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_2.png)\n\n예상대로, directInvoke가 최고의 성적을 거두었습니다. 가장 가까운 경쟁자보다 70배 빨랐습니다. 이는 이러한 작업이 매우 간단하고 멀티스레딩 프레임워크를 사용함으로써 추가적인 오버헤드가 작업 자체의 비용보다 10배 높을 수 있기 때문에 이해할 만합니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 놀랄 만한 일로 두 번째와 세 번째 자리는 예상치 못한 결과가 나왔어요. 둘 다 스레드 수가 고정된 Executors였답니다. 처음에는 directInvoke가 첫 번째로 나올 것으로 예상하고, 그 다음에는 단일 스레드에서의 테스트 케이스, 그 후에 CPU가 그리고 마지막으로 IO가 일어날 것으로 기대했죠. 그러나 스레드 수가 고정된 Executors는 이런 논리를 완전히 깨버렸어요. 동시에 Executors.newWorkStealingPool를 사용해 만든 Executor는 \"무한\" 스레드 수로는 성능이 좋지 못하게 나타났어요.\n\nDispatchers.Default의 시간이 제한과 없는 경우에 각각 다르다는 것도 볼 수 있어요, 그래서 제한이 설정된 거에는 이유가 있어요.\n\n하나의 작업을 처리하는 데 Flow가 가장 큰 오버헤드를 가지고 있다는 것을 주목하는 것도 흥미로운 포인트에요. 다른 모든 경쟁 상대보다 느려요. 그리고 코루틴이 Rx보다 한 스레드에서 더 나을 수 있지만, 스레드 수가 증가할수록 Rx가 선두에 섰다는 점을 알 수 있어요.\n\n요약하자면, 이러한 작업 범주에서는 directInvoke가 가장 효율적이라는 것을 볼 수 있어요. 따라서 이와 같은 작업에는 멀티스레딩 프레임워크를 사용하는 것이 좋지 않아요. 대신 단일 스레드나 소수의 스레드를 사용하는 풀을 사용해야 해요.\n\n<div class=\"content-ad\"></div>\n\n# listsManipulation\n\n지금은 더 복잡한 것, 즉 객체 조작을 살펴 보겠습니다. 객체를 리스트에 추가하면 객체를 다루기가 더 쉬워집니다. 이 작업 범주에는 예를 들어 POJO 매핑이 포함될 수 있습니다.\n\n이 작업 안에서는 매개변수로 받은 숫자와 같은 크기의 새 리스트를 만들고 간단한 연산을 수행한 후, 리스트를 맵으로 변환하고 다시 몇 가지 작업을 수행한 다음 이 컬렉션을 필터링하는 것과 같은 일들을 하게 됩니다. 전반적으로 리스트를 조작합니다.\n\n여기서 복잡성의 기초는 심지어 작업 자체도 아닙니다. 이것은 일반적인 변경 불가능한 리스트이며 시퀀스가 아닙니다. 이는 각 작업 후에 새로운 리스트가 생성된다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nfun listsManipulation(seed: Int): Int {\n    val result = List(seed) { it }\n        .map { it.toFloat() }\n        .map { it + 0.3f }\n        .associateBy { it.toString() }\n        .mapValues { it.value * it.value }\n        .filter { it.value > 5f }\n    \n    return seed\n}\n```\n\n어떻게 되었나요?\n\n![Image](/assets/img/2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_3.png)\n\ndirectInvoke는 빠르게 선두를 내줬어요. 객체 조작과 같은 기본 작업조차 어려움이 있습니다.\n\n\n\n\n<div class=\"content-ad\"></div>\n\n리드는 Executors.newWorkStealingPool로 생성된 Executor가 차지합니다. 이것은 더 간단한 버전인 Executors.newFixedThreadPool보다 효율적입니다.\n\nRx는 약간 앞으로 전진합니다. 앞으로는 Scheduler.computation이 있습니다. 이론적으로, 이 작업에는 더 적은 리소스를 사용하기 때문에 이것이 선호되는 선택입니다.\n\n단일 스레드 테스트 케이스는 목록의 끝에 있지만, directInvoke는 여전히 중간에 남아 있습니다.\n\nflowCPU와 coroutineCPU는 목록의 맨 아래에 있습니다. 이 테스트 케이스들은 CPU 코어의 수만큼의 스레드를 가지고 있으며, 어떠한 제한도 없습니다. 테스트를 다시 실행해봤지만 결과는 동일했습니다. 버그가 있을 수 있다고 생각해 coroutine을 업데이트했지만, 변화는 없었습니다.\n\n<div class=\"content-ad\"></div>\n\nOver the course of my research, I've discovered that CPU test cases tend to have a faster execution time compared to IO for tasks at this level of complexity. \n\n### Storage\n\nWhen it comes to database or file access, it's crucial to address the blocking operation efficiently. In scenarios like this, where we need to put a thread to sleep within an action, we must tread carefully. The sleep duration typically ranges between 500 and 1,490 microseconds, or 0.5 to 1.5 milliseconds. However, relying on the traditional `Thread.sleep` method can lead to inaccurate outcomes due to the phenomenon known as \"busy waiting.\" To overcome this issue, I recommend using `LockSupport.parkNanos` to properly transition the thread into a sleep state.\n\n```kotlin\nprivate fun storage(seed: Int): Int {\n   val timeInMicroseconds = 500 + 10 * seed.toLong()\n   LockSupport.parkNanos(TimeUnit.MICROSECONDS.toNanos(timeInMicroseconds))\n   return seed\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 결과가 나왔어요.\n\n![WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor](/assets/img/2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_4.png)\n\nIO 테스트 케이스를 먼저 실행하고, 그 다음에 CPU를 실행하고, 마지막으로 싱글 스레드를 실행했어요. 교과서에서 본 듯한 내용이죠? \"IO 스레드 풀은 IO 작업에 가장 적합하다\"라고 말해요.\n\nrxIO 테스트 케이스는 flowsIO와 coroutinesIO보다 빠르네요. 아마도 스레드를 생성하는 데 필요한 자원이 가장 적게 사용된 것 같아요. 하지만... 이런 작업에 그다지 중요한 게 아니에요. 차이는 단지 밀리초에 불과해요. 프레임워크 간의 차이가 거의 없어진 것처럼 보여요.\n\n<div class=\"content-ad\"></div>\n\n# 네트워크\n\n음, 네트워크 케이스를 테스트하지 않을 수 없겠죠? 모든 것이 이전 테스트 때와 똑같습니다. 이번에는 스레드가 잠시 동안 0 밀리초에서 99 밀리초 동안 자고 있는 것이죠. 이 테스트에서는 \"바쁜 대기\"로 인한 지연이 더 이상 심각한 역할을 하지 않습니다. 그래서 우리는 Thread.sleep을 사용할 것입니다.\n\n```kotlin\nprivate fun network(seed: Int): Int {\n   TimeUnit.MILLISECONDS.sleep(seed.toLong())\n   return seed\n}\n```\n\n다음 결과에 주목해 주세요.\n\n<div class=\"content-ad\"></div>\n\n🌟 Here is the Markdown format for the image:\n\n![Whatisfaster](/assets/img/2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_5.png)\n\nAnd now, let's dive into the comparison of different frameworks. The difference between them has become quite faint. Although rxIo is slightly ahead by less than 1%, it falls within the margin of error.\n\n# mixed\n\nThe final test holds significant value, especially in relation to both my personal interest and the primary task at hand. We are now navigating tasks with mixed levels of complexity. 🌟\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nprivate fun mixed(seed: Int): Int {\n    return when {\n        seed % 5 == 0 -> network(seed)\n        seed % 3 == 0 -> storage(seed)\n        seed % 2 == 0 -> listsManipulation(seed)\n        else -> arithmetic(seed)\n    }\n}\n```\n\n우리가 가장 긴 작업을 90밀리초 동안 수행할 것이라는 것을 코드에서 확인할 수 있어요.\n\n그래서 여기 결과들이 있어요.\n\n![Image](/assets/img/2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n일반적으로 IO, CPU, One 세 블록으로 나누는 패턴이 동일합니다.\n\n유일한 차이점은 Executors.newWorkStealingPool로 생성된 Executor가 작은 작업을 추가하여 리드를 하는 것입니다. 이는 작업들을 \"도둑질\"하기 때문으로 보입니다.\n\n**결론**\n\n보시다시피, 파일 시스템과 네트워크 작업 시 멀티스레딩의 역할이 거의 사라지고 있습니다. 대부분의 멀티스레딩은 IO 작업에 사용됩니다. 그러므로 성능을 기반으로 한 멀티스레드 프레임워크 선택은 이상합니다. 편리함과 기타 중요한 요소를 고려하는 것이 더 나은 선택입니다.\n\n<div class=\"content-ad\"></div>\n\n그래도 0.5 밀리초 동안 스레드를 차단하는 것보다 간단한 작업을 할 때는 작은 스레드 풀을 사용하는 것이 더 좋습니다. 예를 들어 CPU 코어 수를 풀의 크기로 사용할 수 있습니다.\n\n응용프로그램 실행자(Executors)와 Rx가 이러한 작업에 가장 적합합니다.\n\n예외는 산술 연산, 객체 생성 등과 같이 매우 간단한 작업에 해당합니다. 이러한 경우 스레드를 전혀 사용하지 않는 것이 좋습니다. 왜냐하면 프레임워크에서 스레드 생성하는 데 걸리는 시간이 모든 작업을 완료하는 데 필요한 시간보다 더 오래 걸릴 수 있기 때문입니다.\n\n제 문제를 해결하기 위해 이러한 단계를 따랐습니다:\n\n<div class=\"content-ad\"></div>\n\n- 나는 모든 간단한 작업을 별도의 작업 풀로 분리하고 directInvoke를 사용하여 실행했어.\n- 다른 모든 작업은 동기 및 비동기 코드를 동시에 작성하기 쉽게 하기 때문에 Dispatchers.IO를 사용하여 코루틴에서 실행돼.\n\n이러한 실행 방식에 대해 어떻게 생각하시나요? 현재 어떤 프레임워크를 사용하고 계신가요?","ogImage":{"url":"/assets/img/2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png"},"coverImage":"/assets/img/2024-07-01-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png","tag":["Tech"],"readingTime":20},{"title":"코틀린으로 배우는 디자인 패턴 ","description":"","date":"2024-07-01 20:46","slug":"2024-07-01-DesignPatternswithKotlin","content":"\n\n# Part 1: 싱글턴 패턴 Kotlin에서\n\n![image](/assets/img/2024-07-01-DesignPatternswithKotlin_0.png)\n\n싱글턴 패턴은 \"생성\" 패턴입니다.\n생성 패턴은 객체를 어떻게 생성하는지에 중점을 둡니다.\n\n싱글턴 패턴은 나쁜 평판을 가지고 있습니다. 그것은 한 때 안티 패턴으로 여겨졌습니다. 뭔가가 어디에나 존재한다면 그것이 좋을 수 없다는 것은 합리적입니다. 그럼에도 불구하고 싱글턴은 어디에서나 나타납니다.\n\n<div class=\"content-ad\"></div>\n\n싱글톤 패턴의 기본 논리는 다음과 같습니다.\n1. 시스템 내에서 특정 클래스의 인스턴스는 하나만 존재해야 합니다.\n2. 이 인스턴스는 우리의 범위 내 어디에서든 접근 가능해야 합니다. 이 범위는 우리의 프로그램이거나 그 모듈일 수 있습니다.\n\n코틀린은 싱글톤을 매우 쉽게 만들 수 있습니다. 단순히 다음과 같이 사용하면 됩니다.\n\n![이미지1](/assets/img/2024-07-01-DesignPatternswithKotlin_1.png)\n\n![이미지2](/assets/img/2024-07-01-DesignPatternswithKotlin_2.png)\n\n<div class=\"content-ad\"></div>\n\nHowever, 이것이 잘 맞을 수도 있습니다 considering how 많은 more 단계 is 필요합니다 to get the 같은 functionality in Java or C++.\n\nShall we look at a Java 예시?\n\n![Java Example](/assets/img/2024-07-01-DesignPatternswithKotlin_3.png)\n\nThe steps involved here are\n1. Keeping the constructor private\n2. Make sure only one instance is created\n3. The object is created only when needed and not when the program starts\n4. It works properly from multiple threads\n5. Doesn’t slow down the program by synchronizing to multiple places.\n\n<div class=\"content-ad\"></div>\n\n그래서 여러분은 이 모든 무거운 작업이 개체 내부적으로 처리된다는 것을 보실 수 있습니다.\nKotlin Object의 주요 차이점은 생성자를 가질 수 없다는 것입니다.\n초기화가 필요한 경우(예: 설정)라면 유닛 블록에서 수행할 수 있습니다.\n또한 초기화 로직은 액세스할 때까지 비활성화됩니다(지연 초기화)\n\n![Image](https://miro.medium.com/v2/resize:fit:400/0*E3zEnI5Wmxys1sKh.gif)\n\n싱글톤 패턴의 단점은 다음과 같습니다.\n1. 과도한 결합\n2. 단위 테스트에서의 복잡성\n\n이것은 시리즈 중 첫 번째 블로그입니다. 계속 주목해주세요.\n클랩(clap)을 보내주시면 정말 멋질 것 같아요.","ogImage":{"url":"/assets/img/2024-07-01-DesignPatternswithKotlin_0.png"},"coverImage":"/assets/img/2024-07-01-DesignPatternswithKotlin_0.png","tag":["Tech"],"readingTime":2},{"title":"WWDC 2024, SwiftUI의 최신 업데이트는","description":"","date":"2024-07-01 00:11","slug":"2024-07-01-WWDC2024WhatsnewinSwiftUI","content":"\n\n## 이 특별한 기사에서는 SwiftUI 및 애플의 새로운 발표에 초점을 맞출 것입니다.\n\n# 주요 기능:\n\n- 새로운 앱: 앱이 새롭게 느껴지도록 새로운 기능을 추가하는 것을 목표로 합니다.\n- 플랫폼 활용: 플랫폼마다 개발자로서 앱이 편안하게 느껴질 수 있도록 앱을 미세 조정할 수 있는 도구.\n- 프레임워크 기반: 프레임워크의 기초적인 구조 블록에 대한 대규모 개선.\n- 경험 제작: 몰입형 경험을 위한 새로운 도구 모음.\n\n새로운 SwiftUI 개선에서, 개발자들은 새로운 탭 보기, 메시 그라데이션 및 반응 잘하는 컨트롤을 통해 앱을 정말로 업데이트할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이번에는 WWDC 2024에서 소개된 새로운 기능들을 이해하기 위해 애플 개발자들에 의해 개발된 Karaoke Planner 앱을 리뷰하겠습니다.\n\n# 신선한 앱\n\nA) SwiftUI를 이용한 신선한 탭바 뷰:\n\n![Fresh Tabbar view for with SwiftUI](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_0.png)\n\n<div class=\"content-ad\"></div>\n\niOS 18에서 사이드 바가 훨씬 유연해졌어요. 예를 들어, 왼쪽 상단의 버튼을 클릭하면요.\n\n![image1](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_1.png)\n\n그러면 사이드 바의 위치와 UI가 새로운 방식으로 변경돼요 (탭 바 형태로). 그림 3을 참고해 주세요.\n\n![image2](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_2.png)\n\n<div class=\"content-ad\"></div>\n\n그래서 이 새로운 표현을 어떻게 달성할 수 있는지 살펴보겠습니다. 예제 코드 블록으로 들어가 보죠:\n\n```js\nimport SwiftUI\n\nstruct KaraokeTabView: View {\n    @State var customization = TabViewCustomization()\n    \n    var body: some View {\n        TabView {\n            Tab(\"Parties\", image: \"party.popper\") {\n                PartiesView(parties: Party.all)\n            }\n            .customizationID(\"karaoke.tab.parties\")\n            \n            Tab(\"Planning\", image: \"pencil.and.list.clipboard\") {\n                PlanningView()\n            }\n            .customizationID(\"karaoke.tab.planning\")\n\n            Tab(\"Attendance\", image: \"person.3\") {\n                AttendanceView()\n            }\n            .customizationID(\"karaoke.tab.attendance\")\n\n            Tab(\"Song List\", image: \"music.note.list\") {\n                SongListView()\n            }\n            .customizationID(\"karaoke.tab.songlist\")\n        }\n        .tabViewStyle(.sidebarAdaptable)\n        .tabViewCustomization($customization)\n    }\n}\n\nstruct PartiesView: View {\n    var parties: [Party]\n    var body: some View { Text(\"PartiesView\") }\n}\n\nstruct PlanningView: View {\n    var body: some View { Text(\"PlanningView\") }\n}\n\nstruct AttendanceView: View {\n    var body: some View { Text(\"AttendanceView\") }\n}\n\nstruct SongListView: View {\n    var body: some View { Text(\"SongListView\") }\n}\n\nstruct Party {\n    static var all: [Party] = []\n}\n\n#Preview {\n    KaraokeTabView()\n}\n```\n\n사용자 정의 동작을 통해 탭의 재정렬이나 제거가 프로그래밍적으로 완전히 제어 가능하도록 해줍니다.\n\n```js\n@State var customization = TabViewCustomization()\n```\n\n<div class=\"content-ad\"></div>\n\nThe first image shows the new SwiftUI side bar presented at WWDC 2024. This refreshed side bar feature can now also be utilized on tvOS, expanding its usage across multiple platforms like iPadOS, tvOS, and macOS.\n\nThe second image displays how the tab bar in macOS can be styled to function as a side bar or segmented control. Exciting possibilities lie ahead!\n\n<div class=\"content-ad\"></div>\n\n![2024-07-01-WWDC2024WhatsnewinSwiftUI_5.png](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_5.png)\n\nB) 시트 프레젠테이션 크기:\n\n플랫폼 간에 통합 및 간소화된 시트 프레젠테이션 크기입니다.\n\n개발자로서 우리는 우리 시트 크기를 조정하기 위해 presentationSizing 수정자를 사용할 수 있습니다. 새로운 SwiftUI에는 (.form), (.page) 또는 (.customSizing) 이 세 가지 대안이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nstruct AllPartiesView: View {\n    @State var showAddSheet: Bool = true\n    var parties: [Party] = []\n    \n    var body: some View {\n        PartiesGridView(parties: parties, showAddSheet: $showAddSheet)\n            .sheet(isPresented: $showAddSheet) {\n                AddPartyView()\n                    .presentationSizing(.form)\n            }\n    }\n}\n```\n\n![Image 1](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_6.png)\n\nBesides, SwiftUI also introduces a new Zoom navigation transition. Now, we can showcase the DetailView with a zoom effect by using the new modifier NavigationTransition(.zoom).\n\n![Image 2](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_7.png)\n\n\n<div class=\"content-ad\"></div>\n\n여기 당신을 위해 어떻게 보이는지(Let's get the parties started):\n\n```js\nimport SwiftUI\n\nstruct PartyView: View {\n    var party: Party\n    @Namespace() var namespace\n    \n    var body: some View {\n        NavigationLink {\n            PartyDetailView(party: party)\n                .navigationTransition(.zoom(\n                    sourceID: party.id, in: namespace))\n        } label: {\n            Text(\"Party!\")\n        }\n        .matchedTransitionSource(id: party.id, in: namespace)\n    }\n}\n\nstruct PartyDetailView: View {\n    var party: Party\n    \n    var body: some View {\n        Text(\"PartyDetailView\")\n    }\n}\n\nstruct Party: Identifiable {\n    var id = UUID()\n    static var all: [Party] = []\n}\n\n#미리보기 {\n    @Previewable var party: Party = Party()\n    NavigationStack {\n        PartyView(party: party)\n    }\n}\n```\n\nKeep in mind, these new Tabview features are available on iPadOS 18 and forward.\n\n<div class=\"content-ad\"></div>\n\nC) 컨트롤 API:\n\n이제 개발자들은 토글이나 버튼과 같은 크기 조절이 가능한 자체 컨트롤을 컨트롤 센터 또는 잠금 화면에 추가할 수 있습니다.\n\n이러한 컨트롤은 액션 버튼에 의해 활성화될 수도 있습니다. 컨트롤은 앱 인텐트로 쉽게 구축할 수 있는 새로운 종류의 위젯입니다!\n\n![이미지](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_9.png)\n\n<div class=\"content-ad\"></div>\n\n아래 코드에서는 새로운 위젯을 제어 센터에 추가하는 방법을 보여줍니다.\n\n```swift\nimport WidgetKit\nimport SwiftUI\n\nstruct StartPartyControl: ControlWidget {\n    var body: some ControlWidgetConfiguration {\n        StaticControlConfiguration(\n            kind: \"com.apple.karaoke_start_party\"\n        ) {\n            ControlWidgetButton(action: StartPartyIntent()) {\n                Label(\"파티 시작!\", systemImage: \"music.mic\")\n                Text(PartyManager.shared.nextParty.name)\n            }\n        }\n    }\n}\n\n// 모델 코드\n\nclass PartyManager {\n    static let shared = PartyManager()\n    var nextParty: Party = Party(name: \"WWDC Karaoke\")\n}\n\nstruct Party {\n    var name: String\n}\n\n// AppIntent\n\nimport AppIntents\n\nstruct StartPartyIntent: AppIntent {\n    static let title: LocalizedStringResource = \"파티 시작\"\n    \n    func perform() async throws -> some IntentResult {\n        return .result()\n    }\n}\n```\n\nD) 벡터화 및 함수 플롯\n\nSwift 차트에서의 함수 플로팅은 그래프를 그리는 것을 쉽게 만들어줍니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\nimport Charts\n\nstruct AttendanceView: View {\n    var body: some View {\n        Chart {\n          LinePlot(x: \"Parties\", y: \"Guests\") { x in\n            pow(x, 2)\n          }\n          .foregroundStyle(.purple)\n        }\n        .chartXScale(domain: 1...10)\n        .chartYScale(domain: 1...100)\n    }\n}\n\n# Preview {\n    AttendanceView()\n        .padding(40)\n}\n```\n\n![WWDC2024](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_10.png)\n\n**E) 테이블 열 동적 생성**\n\n\"TableColumnForEach\"를 사용하여 동적 테이블 열 수를 가질 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct SongCountsTable: View {\n\n    var body: some View {\n        Table(Self.guestData) {\n            // A static column for the name\n            TableColumn(\"Name\", value: \\.name)\n            \n            TableColumnForEach(Self.partyData) { party in\n                TableColumn(party.name) { guest in\n                    Text(guest.songsSung[party.id] ?? 0, format: .number)\n                }\n            }\n        }\n    }\n    \n    private static func randSongsSung(low: Bool = false) -> [Int : Int] {\n        var songs: [Int : Int] = [:]\n        for party in partyData {\n            songs[party.id] = low ? Int.random(in: 0...3) : Int.random(in: 3...12)\n        }\n        return songs\n    }\n    \n    private static let guestData: [GuestData] = [\n        GuestData(name: \"Sommer\", songsSung: randSongsSung()),\n        GuestData(name: \"Sam\", songsSung: randSongsSung()),\n        GuestData(name: \"Max\", songsSung: randSongsSung()),\n        GuestData(name: \"Kyle\", songsSung: randSongsSung(low: true)),\n        GuestData(name: \"Matt\", songsSung: randSongsSung(low: true)),\n        GuestData(name: \"Apollo\", songsSung: randSongsSung()),\n        GuestData(name: \"Anna\", songsSung: randSongsSung()),\n        GuestData(name: \"Raj\", songsSung: randSongsSung()),\n        GuestData(name: \"John\", songsSung: randSongsSung(low: true)),\n        GuestData(name: \"Harry\", songsSung: randSongsSung()),\n        GuestData(name: \"Luca\", songsSung: randSongsSung()),\n        GuestData(name: \"Curt\", songsSung: randSongsSung()),\n        GuestData(name: \"Betsy\", songsSung: randSongsSung())\n    ]\n    \n    private static let partyData: [PartyData] = [\n        PartyData(partyNumber: 1, numberGuests: 5),\n        PartyData(partyNumber: 2, numberGuests: 6),\n        PartyData(partyNumber: 3, numberGuests: 7),\n        PartyData(partyNumber: 4, numberGuests: 9),\n        PartyData(partyNumber: 5, numberGuests: 9),\n        PartyData(partyNumber: 6, numberGuests: 10),\n        PartyData(partyNumber: 7, numberGuests: 11),\n        PartyData(partyNumber: 8, numberGuests: 12),\n        PartyData(partyNumber: 9, numberGuests: 11),\n        PartyData(partyNumber: 10, numberGuests: 13),\n    ]\n    \n}\n\nstruct GuestData: Identifiable {\n    let name: String\n    let songsSung: [Int : Int]\n    \n    let id = UUID()\n}\n\nstruct PartyData: Identifiable {\n    let partyNumber: Int\n    let numberGuests: Int\n    let symbolSize = 100\n    \n    var id: Int {\n        partyNumber\n    }\n    \n    var name: String {\n        \"\\(partyNumber)\"\n    }\n}\n\n#Preview {\n    SongCountsTable()\n        .padding(40)\n}\n```\n\n![Image](https://tarotcards.com/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_11.png)\n\nMesh Gradients\n\nSwiftUI가 색상이 풍부한 메시 그라데이션을 위한 일등 시민 지원을 추가했습니다. 그리드 색상의 점을 보간하는 방식으로 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n이 특별한 새로운 기능으로 우리 뷰에 그라데이션 배경색을 적용할 수 있게 되었어요.\n\n![Example](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_12.png)\n\n```swift\nimport SwiftUI\n\nstruct MyMesh: View {\n    var body: some View {\n        MeshGradient(\n            width: 3,\n            height: 3,\n            points: [\n                .init(0, 0), .init(0.5, 0), .init(1, 0),\n                .init(0, 0.5), .init(0.3, 0.5), .init(1, 0.5),\n                .init(0, 1), .init(0.5, 1), .init(1, 1)\n            ],\n            colors: [\n                .red, .purple, .indigo,\n                .orange, .cyan, .blue,\n                .yellow, .green, .mint\n            ]\n        )\n    }\n}\n\n#Preview {\n    MyMesh()\n        .statusBarHidden()\n}\n```\n\nG) 출시 씬 문서화 (iPadOS)\n\n<div class=\"content-ad\"></div>\n\n문서 기반 응용 프로그램은 이제 DocumentGroup을 구현하여 새로운 UI를 가질 수 있습니다. DocumentGroup을 사용하면 다음과 같은 UI가 생깁니다:\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_13.png)\n\n지금 보시는 것처럼 \"Playgrounds title\", \"Learn to Code\" 버튼 및 \"New App\" 버튼이 디자인에 추가되었습니다.\n\n또한 이 UI 요소 외에도, 우리는 도면 15에서 나타나는 바와 같이 배경 액세서리, 양 쪽 (왼쪽 및 오른쪽)을위한 전경 액세서리를 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_14.png)\n\n예제 코드 Document Groups를 위해:\n\n```js\nDocumentGroupLaunchScene(\"Your Lyrics\") {\n    NewDocumentButton()\n    Button(\"New Parody from Existing Song\") {\n        // Do something!\n    }\n} background: {\n    PinkPurpleGradient()\n} backgroundAccessoryView: { geometry in\n    MusicNotesAccessoryView(geometry: geometry)\n         .symbolEffect(.wiggle(.rotational.continuous()))\n} overlayAccessoryView: { geometry in\n    MicrophoneAccessoryView(geometry: geometry)\n}\n```\n\nH) 새로운 심볼 효과:\n\n<div class=\"content-ad\"></div>\n\n이제 심볼들은 새로운 능력을 갖고 있어요. 특정 효과를 받아들이는 우리 어플리케이션들의 사용 예시입니다:\n\n![SF Symbol Example](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_15.png)\n\n다른 새로운 SF 심볼 효과들은 다음과 같아요:\n\n.wiggle effect: 어떤 방향이나 각도로 심볼을 진동시켜서 주의를 끌어요\n\n<div class=\"content-ad\"></div>\n\n**이미지:**\n![이미지](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_16.png)\n\n**.breathe 효과:** 심볼을 부드럽게 확대/축소하여 지속적인 활동을 나타냅니다.\n\n**이미지:**\n![이미지](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_17.png)\n\n**.rotate 효과:** 심볼의 일부분을 지정된 앵커 포인트 주변으로 회전시킵니다.\n\n<div class=\"content-ad\"></div>\n\n이미지를 Markdown 형식으로 변경해주세요.\n\n일부 기존 프리셋은 새로운 기능으로 개선되었습니다.\n\n예를 들어, 기본 \"대체\" 애니메이션은 이제 새로운 MagicReplace 동작을 선호합니다.\n\nMagicReplace를 사용하면 기호가 부드럽게 배지와 슬래시를 애니메이션화합니다.\n\n<div class=\"content-ad\"></div>\n\n# 플랫폼 활용하기:\n\n**A) 창 관리**\n\n새로운 윈도우 관리 SwiftUI 수정자들은 macOS의 창에 새로운 스타일과 레벨을 추가하는 데 도움이 됩니다.\n\n```swift\nWindow(\"가사 미리보기\", id: \"lyricPreview\") {\n    LyricPreview()\n}\n  .windowStyle(.plain)\n  .windowLevel(.floating)\n  .defaultWindowPlacement { content, context in\n      let displayBounds = context.defaultDisplay.visibleRect\n      let contentSize = content.sizeThatFits(.unspecified)\n      return topPreviewPlacement(size: contentSize, bounds: displayBounds)\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n지금은 창에 드래그 제스처를 추가할 수 있어요:\n\n![image1](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_20.png)\n\n```js\nText(currentLyric)\n    .background(.thinMaterial, in: .capsule)\n    .gesture(WindowDragGesture())\r\n```\n\n<div class=\"content-ad\"></div>\n\n이번에 추가된 새 창 수정자는 visionOS에서도 작동합니다.\n\n새 창 수정자 외에도, 원래 창을 숨기고 새 창을 열 수 있는 푸시 창 작업이 있습니다.\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_21.png)\n\n창에 대한 자세한 정보는 다음 링크를 참조하십시오.\n\n<div class=\"content-ad\"></div>\n\nB) 새로운 SwiftUI 입력 방식 (visionOS)\n\nSwiftUI는 각 플랫폼이 제공하는 독특한 입력 방식을 활용할 수 있는 많은 새로운 도구를 제공합니다.\n\n예를 들어 visionOS에서는 뷰가 사람들이 보거나 손가락을 가까이 대거나 포인터를 이동시킬 때 반응하도록 만들 수 있습니다.\n\n![링크](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_22.png)\n\n<div class=\"content-ad\"></div>\n\n![2024-07-01-WWDC2024WhatsnewinSwiftUI_23.png](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_23.png)\n\nSo, 이 그림 24와 25를 고려해 보면 프로필이 축소되지 않았고 사용자가 작업을 수행함에 따라 (즉, 보기를 보는 것에 의해), 프로필 이미지가 확장되어 사용자에 대한 더 많은 정보를 볼 수 있었습니다.\n\n새로운 호버 효과 내에서 뷰의 상태를 제어하고 활성 및 비활성 사이의 전환을 조정할 수 있습니다.\n\n```swift\nstruct ProfileButtonStyle: ButtonStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .background(.thinMaterial)\n            .hoverEffect(.highlight)\n            .clipShape(.capsule)\n            .hoverEffect { effect, isActive, _ in\n                effect.scaleEffect(isActive ? 1.05 : 1.0)\n            }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nC) 수정자 키 대체 옵션들\n\niPadOS, macOS, 그리고 visionOS 앱들은 키보드 지원을 제공합니다 (바로가기로).\n\n예를 들어, macOS에서 앱에 새로운 바로가기 수정자 키를 추가하고 싶다면 이 몇 줄의 코드로 가능합니다:\n\n```js\nButton(\"창에서 가사 미리보기\") {\n    // 창에서 미리보기 표시\n}\n.modifierKeyAlternate(.option) {\n    Button(\"전체 화면에서 가사 미리보기\") {\n        // 전체 화면에서 미리보기 표시\n    }\n}\n.keyboardShortcut(\"p\", modifiers: [.shift, .command])\n```\n\n<div class=\"content-ad\"></div>\n\n맥OS의 메인 메뉴에서, 미리보기 창을 열기 위한 항목이 있다고 가정해봅시다. 위의 코드 조각은 이 사용 예시를 나타내며 아래와 같은 기능이 얻어지게 됩니다:\n\n![preview window](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_24.png)\n\nD) 포인터 상호 작용\n\n포인터 상호 작용은 다양한 기기에서의 중요한 입력 방식 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\n![image1](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_25.png)\n\n포인터 스타일 API를 사용하면 시스템 포인터의 외관과 가시성을 사용자 정의할 수 있습니다.\n\n![image2](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_26.png)\n\niPadOS 17.5에서는 Apple Pencil과 Apple Pencil Pro의 기능을 지원하는 SwiftUI가 포함되어 있습니다. 더블 탭과 스퀴즈 기능도 사용 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n**애플 펜슬 스퀴즈 액션**으로 이제 제스처에서 정보를 수집하여 선호하는 조치를 확인할 수 있어요.\n\n![WWDC 2024에서의 SwiftUI 새로운 기능](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_27.png)\n\nE) 위젯 및 실시간 활동\n\n이제 위젯과 실시간 활동이 자동으로 Apple 워치에 표시될 거랍니다.\n\n<div class=\"content-ad\"></div>\n\n개발자로서, watchOS에서 콘텐츠를 조정할 수 있는 새로운 .supplementalActivityFamilies 수정자를 활용할 수 있습니다.\n\n![Image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_28.png)\n\n![Image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_29.png)\n\n그리고 사용자가 실시간 활동을 더욱 향상시킬 수 있도록 두 번 탭을 적용할 수도 있습니다. 이를 위해 .handGestureShortcut 수정자를 활용하세요.\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_30.png)\n\n# Framework Foundations\n\nA) Custom Containers\n\nA new API on ForEach, `subviewOf`, allows us to iterate over the subviews of a given view. In the example below, each subview is wrapped in its own `CardView`.\n\n<div class=\"content-ad\"></div>\n\n이를 사용하여 SwifUI의 내장 컨테이너인 목록과 동일한 기능을 가진 사용자 정의 컨테이너를 만들 수 있습니다. 이는 정적 및 동적 콘텐츠를 혼합하여 섹션을 지원하고 특정 수정자에 컨테이너를 추가하는 것을 포함합니다.\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_31.png)\n\n```js\nstruct DisplayBoard<Content: View>: View {\n  @ViewBuilder var content: Content\n\n  var body: some View {\n    DisplayBoardCardLayout {\n      ForEach(subviewOf: content) { subview in\n        CardView {\n          subview\n        }\n      }\n    }.background(BoardBackgroundView())\n  }\n}\n\nDisplayBoard {\n  Text(\"Scrolling in the Deep\")\n  Text(\"Born to Build & Run\")\n  Text(\"Some Body Like View\")\n\n  ForEach(songsFromSam) { song in\n    Text(song.title)\n  }\n}\n```\n\n이는 섹션 또한 지원하기 위해 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n**Entry macro:**\n\n![](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_32.png)\n\n![](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_33.png)\n\nB) 편의성 향상신 시사점\n\n<div class=\"content-ad\"></div>\n\n환경키에 대한 완전한 준수 쓰기와 환경 값에 대한 확장을 작성해야 했던 것을 간단한 속성과 Entry 매크로로 대체할 수 있게 되었습니다.\n\n이전: 원하는 구조체에 대한 환경으로 SwiftUI 프로젝트에서 사용할 수 있게끔 하기 위해 enviromentKey에 대한 확장을 작성해야 했습니다.\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_34.png)\n\n이후: 현재 @Entry로 표시해서 SwiftUI가 선언을 자동으로 처리하고 SwiftUI 프로젝트 내에서 환경 변수로 사용할 준비를 갖추도록 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\n마법사 파티 컬러: Color = .보라\n```\n\n엔트리 매크로는 환경 값과 함께 사용되는 것뿐만 아니라, 엔트리 매크로는 포커스 값, 트랜잭션 및 컨테이너 값에서도 사용할 수 있습니다.\n\n```swift\n마법사 노트: String? = nil\n```\n\n```swift\n애니메이션 파티 아이콘: Bool = false\n```\n\n```swift\n디스플레이 보드 카드 스타일: DisplayBoardCardStyle = .테두리\n```\n\n## 기본 접근성 레이블 보강:\n\n\n<div class=\"content-ad\"></div>\n\n현재 SwiftUI의 컨트롤에 프레임워크가 제공하는 레이블을 덮어쓰지 않고 추가 정보를 추가할 수 있습니다. 자세한 정보는 링크를 참조해주세요.\n\n![2024-07-01-WWDC2024WhatsnewinSwiftUI_35](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_35.png)\n\n## Xcode 미리보기에 새로운 동적 링킹 아키텍처가 있습니다\n\n이를 통해 프로젝트를 다시 빌드할 필요 없이 미리보기와 빌드 및 실행 간에 전환할 수 있어 반복 속도를 높일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이제는 미리보기 설정도 더 쉬워졌어요. @Previewable 매크로를 사용하여 미리보기에서 상태를 바로 사용할 수 있게 되어, 뷰에 미리보기 내용을 감싸는 부분에서 발생했던 불필요한 작업을 줄일 수 있어요.\n\n![Image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_36.png)\n\n## 텍스트 작업 및 선택 관리를 위한 새로운 방법:\n\n이제 SwiftUI는 텍스트 편집 컨트롤 내의 텍스트 선택에 프로그래밍적 접근과 제어를 제공해요.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_37.png)\n\n지금은 선택한 범위와 같은 선택 속성을 읽을 수 있습니다.\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_38.png)\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_39.png)\n\n<div class=\"content-ad\"></div>\n\n이를 사용하여 검사자에서 선택한 단어에 대한 제안된 운율을 보여줄 수 있어요.\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_40.png)\n\n## 새로운 .searchFocused로:\n\n우리는 프로그래밍 방식으로 검색 필드의 포커스 상태를 제어할 수 있습니다. 이는 검색 필드가 포커스된 상태인지 확인하고, 프로그래밍 방식으로 검색 필드로 포커스를 이동하거나 검색 필드에서 포커스를 이동할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이제는 어떤  텍스트 필드에 새 텍스트 제안을 추가할 수 있습니다.\n\n몇 줄의 코드만으로 사용자에게 제안된 텍스트를 제공할 수 있습니다. 제안 사항은 드롭다운 메뉴로 나타나며, 옵션을 선택하면 텍스트 필드가 선택한 완료로 업데이트됩니다.\n\n<div class=\"content-ad\"></div>\n\n텍스트를 한국어로 번역해보겠어요!\n\n\n![이미지](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_42.png)\n\n예시 코드는 다음과 같습니다:\n\n![이미지](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_43.png)\n\n## 그래픽 기능:\n\n\n<div class=\"content-ad\"></div>\n\n색상 조합: 개발자로서 우리는 색상을 섞어 사용할 수 있습니다. 다른 색상과 주어진 양으로 섞는 색상 혼합기능이 새롭게 추가되었어요.\n\n![Image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_44.png)\n\n사용자 정의 쉐이더 기능:\n\n사용자 정의 쉐이더 기능은 쉐이더가 처음 사용되기 전에 사전 컴파일할 수 있는 기능을 가지고 있어요. 게으른 쉐이더 컴파일로 인한 프레임 드랍을 피할 수 있답니다.\n\n<div class=\"content-ad\"></div>\n\n**스크롤링 향상:**\n\n개발자들에게 세밀한 제어권을 주는 새로운 API가 많이 추가되었습니다.\n\n현재 우리는 onScrollGeometryChanged를 통해 ScrollView의 상태와 깊은 수준의 통합을 가질 수 있습니다. 이를 통해 콘텐츠 오프셋, 콘텐츠 크기 등의 변경 사항에 효율적으로 반응할 수 있습니다. 스크롤 뷰의 콘텐츠 위로 스크롤을 넘어갈 때 나타나는 \"초대로 돌아가기\" 버튼과 같이요.\n\n<div class=\"content-ad\"></div>\n\n이제 뷰의 가시성이 스크롤로 변경된 것을 감지할 수 있어요!\n\n![image](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_48.png)\n\n<div class=\"content-ad\"></div>\n\n**새로운 스위프트 6 언어 모드:**\n\n화면 이동이나 사운드 자동 재생과 같은 콘텐츠 중심의 멋진 경험을 만들 수 있게 해주는 기능이 추가되었습니다.\n\n컴파일 시간 데이터 경쟁 안전성을 제공하고, SwiftUI는 앱에서 새로운 언어 모드를 쉽게 적용할 수 있도록 API를 개선했습니다.\n\nSwiftUI의 뷰는 항상 메인 액터에서 평가되어 왔고, 이제 뷰 프로토콜에 메인 액터 주석이 표시되어 해당 사항이 반영되었습니다.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 이 의미는 모든 View를 준수하는 모든 타입이 기본적으로 main actor에 의해 암시적으로 격리된다는 것을 의미합니다. 따라서 View를 명시적으로 main actor로 표시했다면 그 주석을 제거해도 동작에 아무런 변경이 없습니다.\n\n새로운 Swift 6 언어 모드는 선택 사항이므로 준비가 되면 언제든지 그것을 활용할 수 있습니다. 어떻게 응용 프로그램을 Swift6로 마이그레이션하는지 알아보세요.\n\n<div class=\"content-ad\"></div>\n\n향상된 상호 운용성:\n\nSwiftUI는 새로운 앱을 만드는 데뿐만 아니라 UIKit과 AppKit으로 작성된 기존 앱에 새로운 기능을 추가하는 데도 설계되었습니다.\n\n## 제스처 상호 운용성\n\n이제 내장된 또는 사용자 정의 UIGestureRecognizer를 취해서 Swift SwiftUI 뷰 계층 구조에서 사용할 수 있습니다. 직접 UIKit으로 뒷받침되지 않은 SwiftUI 뷰에서도 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n마크다운 포맷으로 변경해드릴게요.\n\n\n![Image 1](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_51.png)\n\n## UIKit 및 AppKit에서 SwiftUI 애니메이션\n\nUIKit 및 AppKit에서 SwiftUI 애니메이션의 힘을 활용할 수 있습니다.\n\n![Image 2](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_52.png)\n\n\n<div class=\"content-ad\"></div>\n\nExperiencing the Art of Craft:\n\n새로운 API로 볼륨 및 몰입형 공간, 그리고 텍스트 효과를 다룰 수 있습니다.\n\n### 사용자 정의 텍스트 렌더러:\n\n예를 들어 단어를 강조하는 데 다음 TextRenderer 프로토콜을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-07-01-WWDC2024WhatsnewinSwiftUI_53.png](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_53.png)\n\nKaraokeRenderer는 원본 그림 뒤에 복사된 텍스트를 생성하며, 이는 흐리고 색조가 조절된 상태로 표시됩니다.\n\n![2024-07-01-WWDC2024WhatsnewinSwiftUI_54.png](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_54.png)\n\n![2024-07-01-WWDC2024WhatsnewinSwiftUI_55.png](/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_55.png)","ogImage":{"url":"/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_0.png"},"coverImage":"/assets/img/2024-07-01-WWDC2024WhatsnewinSwiftUI_0.png","tag":["Tech"],"readingTime":21},{"title":"Jetpack Compose에서 공유 요소 전환 풍부한 사용자 경험 제공하는 방법","description":"","date":"2024-07-01 00:06","slug":"2024-07-01-SharedElementTransitionInJetpackComposeProvideEnrichedUserExperiences","content":"\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*XWziJJSgLGdw4aWm9vDCHA.gif)\n\n안녕하세요! 오늘은 공유 요소 전환 또는 컨테이너 변형에 대해 이야기해보려고 해요. 이 애니메이션은 두 UI 요소 사이에 시각적인 연결을 만들어 앱의 미적인 요소와 사용자 경험을 현격하게 향상시킵니다. 화면 간의 전환을 실현하여 두드러지지 않고 통합되는 것은 사용자의 참여와 앱 내 공간 인식을 유지하는 데 도움이 됩니다.\n\n공유 요소 전환 애니메이션을 사용하면 사용자의 주요 요소에 집중할 수 있어 인지 부하와 혼란을 줄이고 전반적인 사용자 경험을 향상시킬 수 있습니다. 이러한 애니메이션을 통해 앱 내비게이션을 더 직관적으로 만들고 동적이고 매력적인 느낌을 주어 상호작용 품질을 현격하게 향상시킬 수 있습니다.\n\nJetpack Compose에서는 LookaheadScope 또는 Orbital과 같은 라이브러리를 사용하여 공유 요소 전환을 구현할 수 있습니다. 그러나 이러한 애니메이션을 Compose Navigation 라이브러리와 통합하는 것에는 아직 일부 제한 사항이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n행운히도, Compose UI 버전 1.7.0-alpha07에서는 공유 요소 전환을 위한 새로운 API가 도입되었습니다. 이 글에서는 최신 버전의 Compose UI를 사용하여 다양한 상황에서 공유 요소 전환과 컨테이너 변형을 어떻게 원활하게 구현하는지 알아보겠습니다.\n\n# 의존성 구성\n\n새로운 공유 요소 전환 API를 사용하기 위해서는 다음과 같이 Jetpack Compose UI 및 animation의 최신 버전(1.7.0-alpha07 이상)을 사용해야 합니다:\n\n```js\ndependencies {\n    implementation(androidx.compose.ui:ui:1.7.0-alpha07)\n    implementation(androidx.compose.animation:animation:1.7.0-alpha07)\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# SharedTransitionLayout 및 Modifier.sharedElement\n\nCompose UI 및 애니메이션 버전 1.7.0-alpha07은 공유 요소 전환을 구현할 수 있는 주요 API를 도입했습니다. SharedTransitionLayout 및 Modifier.sharedElement이 그 중 하나입니다.\n\n- SharedTransitionLayout: 이 Composable은 SharedTransitionScope를 제공하는 컨테이너 역할을 합니다. 이를 통해 Modifier.sharedElement을 비롯한 기타 관련 API를 사용할 수 있습니다. 공유 요소 전환의 핵심 기능은 이 Composable 내에서 발생합니다. 내부적으로 SharedTransitionScope는 LookaheadScope API를 활용하여 이러한 전환을 용이하게 합니다. 그러나 LookaheadScope에 대해 상세한 지식은 필요하지 않습니다. 새 API가 이 복잡성을 효과적으로 캡슐화했기 때문입니다.\n- Modifier.sharedElement: 이 modifier는 SharedTransitionLayout 내에서 공유 전환을 수행해야 하는 Composable를 식별합니다. 동일한 SharedTransitionScope 내의 다른 Composable과 변환을 수행해야 함을 효과적으로 표시합니다.\n\n이제 두 API를 어떻게 활용할 수 있는지 예제를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n자세히 살펴봅시다. 이 예제를 자세히 살펴보겠습니다. Row에는 이미지와 텍스트가 가로로 표시됩니다. Row를 클릭하면 이미지와 텍스트가 세로로 배열된 Column으로 변환됩니다. SharedTransitionLayout 내에서 sharedElement 수정자가 사용된 것을 알 수 있습니다. 다음 세 가지 매개변수를 받습니다:\n\n- state: SharedContentState는 sharedBounds/sharedElement의 속성에 액세스할 수 있도록 설계되었으며 동일한 키의 일치 여부(SharedTransitionScope 내에서 일치하는 것이 발견되었는지 여부 등)를 확인합니다. rememberSharedContentState API를 사용하여 SharedContentState 인스턴스를 만들 수 있습니다. 애니메이션 중에 일치시켜야 할 구성 요소를 식별하는 키를 제공하십시오. 이 키는 전환 발생 시 올바른 구성 요소가 연결되도록 합니다.\n- animatedVisibilityScope: 이 매개변수는 animatedVisibilityScope의 대상 상태를 기반으로 공유 요소의 경계를 정의합니다. NavGraphBuilder.composable 함수와 통합할 수 있어서 Compose 네비게이션 라이브러리와 원활하게 작동할 수 있습니다. 나중 섹션에서 자세히 살펴보겠습니다.\n- boundsTransform: 이 람다 함수는 FiniteAnimationSpec를 가져오고 반환하며, 공유 요소 전환에 적합한 애니메이션 명세를 적용하는 데 사용됩니다.\n\n위의 코드를 실행한 후 다음과 같은 결과가 나타날 것입니다:\n\n![Click here](https://miro.medium.com/v2/resize:fit:752/1*YACtgRhSLW3hYGgfYHLgSw.gif)\n\n<div class=\"content-ad\"></div>\n\n# 네비게이션과 공유 요소 전환이 함께하는 방법\n\n새로운 공유 요소 전환 API에서는 Compose Navigation 라이브러리와 호환성이 있습니다. 이 향상된 기능을 사용하면 앱 전체에서 더 부드러운 네비게이션 흐름을 가능케 하도록 다른 네비게이션 그래프에 있는 Composable 함수들 간의 공유 요소 전환을 구현할 수 있습니다.\n\n이제 네비게이션 라이브러리와 공유 요소 전환을 통합하는 방법을 알아보겠습니다. 두 가지 간단한 화면을 만들어보겠습니다: 홈 화면(목록 포함)과 상세 화면. 이를 통해 LazyColumn과 같은 방법으로 이 두 개의 다른 네비게이션 그래프 사이에서 요소들을 부드럽게 전환하는 방법을 보여줄 것입니다.\n\n먼저, 아래 예시처럼 빈 Composable 화면으로 NavHost를 설정해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n네비게이션 라이브러리를 사용하여 공유 요소 전환을 구현하려면 NavHost를 SharedTransitionLayout 안에 넣는 것이 중요합니다. 이 설정을 통해 다양한 네비게이션 목적지 간에 공유 요소 전환을 제대로 처리할 수 있습니다.\n\n그런 다음, 이름과 이미지에 대한 속성이 포함된 Pokemon이라는 샘플 데이터 클래스를 정의하세요. 그런 다음, 아래 예시에 설명된 대로 모의 Pokemon 데이터 목록을 만들어보세요:\n\n이제 홈 화면을 구성하는 composable을 구현해봅시다. 각 목록 항목은 이미지와 텍스트가 가로로 나란히 표시되는 행으로 표시됩니다:\n\n본 예시에서는 이미지와 텍스트 컴포넌트의 수정자(modifiers)가 Modifier.sharedElement 함수를 사용한다는 것을 알 수 있습니다. 각 요소에는 고유한 키 값을 할당하여 목록의 여러 항목 중에서 구별할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 공유된 요소 전환이 올바르게 작동하도록 하려면 출발 화면의 요소에 할당된 구체적인 키 값이 이동 흐름에서 대응되는 목적지 화면의 요소에 사용된 값과 일치해야 합니다. 다른 화면을 탐색하면서 다양한 컴포저블 간에 원활한 전환을 가능하게 하는 데 이 일치가 중요합니다.\n\n마지막으로 세부 화면을 구현해 봅시다. 이 화면은 간단히 이미지와 텍스트를 표시할 것입니다. 게다가, 화면을 클릭할 때 홈 화면으로 돌아가는 기능도 포함될 것입니다:\n\n따라서 전체 코드는 아래와 같이 될 것입니다:\n\n예시 코드를 실행하면 다음 결과를 관찰할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:866/1*vBg1PonRrhkP_hS5q0i8tw.gif)\n\nIf you want to see practical examples, check out the Pokedex-Compose open-source project on GitHub. It showcases the shared element transition APIs in action.\n\n# Modifier.sharedBounds for Container Transform\n\nNow, let's dive into the container transform. Modifier.sharedBounds() is similar to Modifier.sharedElement(), but with a key difference. Modifier.sharedBounds() is best suited for content that looks different visually during transitions. On the other hand, Modifier.sharedElement() is used for content that remains visually consistent, like images. This difference is particularly helpful in scenarios like the container transform pattern.\n\n<div class=\"content-ad\"></div>\n\n이전 예제를 활용하여 컨테이너 변환을 구현하는 것은 간단합니다. Composable 트리의 루트 계층에 Modifier.sharedBounds()를 추가하고 Modifier.sharedElement() 함수를 제거하면 됩니다. 이 수정을 통해 UI 구성 요소 간에 시각적으로 다른 요소들 간의 전환을 가능케 합니다.\n\n이전 섹션의 코드를 아래와 같이 수정해 보겠습니다: \n\n세부사항을 살펴보면, 홈 컴포저블의 Row와 세부사항 컴포저블의 Column이 모두 위의 예제에서 보여주는 것처럼 Modifier.sharedBounds()를 활용하고 있음을 알 수 있습니다. 이게 전부입니다! 코드를 실행하면 다음과 같은 애니메이션의 결과를 확인할 수 있을 것입니다:\n\n![animation](https://miro.medium.com/v2/resize:fit:926/1*VgYm12rOK7UdNWpM1C4rhQ.gif)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이번 글에서는 다양한 예시를 활용하여 공유 요소 전환과 컨테이너 변형을 구현하는 방법을 배웠습니다. Jetpack Compose가 얼마나 발전했는지 보는 것은 인상적입니다. 이를 통해 복잡한 애니메이션을 쉽게 만들 수 있게 되었습니다. 이 두 종류의 애니메이션은 화면 이동을 직관적이고 동적으로 만들어 사용자 경험을 크게 향상시킬 수 있습니다. 그러나 이러한 애니메이션을 분별적으로 사용하는 것이 중요합니다. 과도하게 사용하는 대신 적절하게 활용함으로써 자연스럽고 매력적인 사용자 경험을 보장할 수 있습니다.\n\n만약 실제 적용 사례를 보고 싶다면, GitHub의 Pokedex-Compose 오픈 소스 프로젝트를 살펴보세요. 이 프로젝트는 공유 요소 전환 API와 여러 Jetpack 라이브러리가 어떻게 작용하는지를 보여줍니다.\n\n이 글에 대한 질문이나 피드백이 있다면, 저자를 Twitter(@github_skydoves) 또는 GitHub에서 찾을 수 있습니다. 또한 Stream을 최신 상태로 유지하고 싶다면, 훌륭한 기술 콘텐츠를 더 보려면 Twitter(@getstream_io)를 팔로우하세요.\n\n<div class=\"content-ad\"></div>\n\n행복한 코딩하세요!\n\n— Jaewoong","ogImage":{"url":"/assets/img/2024-07-01-SharedElementTransitionInJetpackComposeProvideEnrichedUserExperiences_0.png"},"coverImage":"/assets/img/2024-07-01-SharedElementTransitionInJetpackComposeProvideEnrichedUserExperiences_0.png","tag":["Tech"],"readingTime":6}],"page":"1","totalPageCount":1,"totalPageGroupCount":1,"lastPageGroup":1,"currentPageGroup":0},"__N_SSG":true}